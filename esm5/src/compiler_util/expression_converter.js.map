{"version":3,"file":"expression_converter.js","sourceRoot":"","sources":["../../../../../../packages/compiler/src/compiler_util/expression_converter.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as cdAst from '../expression_parser/ast';\nimport {Identifiers} from '../identifiers';\nimport * as o from '../output/output_ast';\n\nexport class EventHandlerVars { static event = o.variable('$event'); }\n\nexport interface LocalResolver { getLocal(name: string): o.Expression|null; }\n\nexport class ConvertActionBindingResult {\n  /**\n   * Store statements which are render3 compatible.\n   */\n  render3Stmts: o.Statement[];\n  constructor(\n      /**\n       * Render2 compatible statements,\n       */\n      public stmts: o.Statement[],\n      /**\n       * Variable name used with render2 compatible statements.\n       */\n      public allowDefault: o.ReadVarExpr) {\n    /**\n     * This is bit of a hack. It converts statements which render2 expects to statements which are\n     * expected by render3.\n     *\n     * Example: `<div click=\"doSomething($event)\">` will generate:\n     *\n     * Render3:\n     * ```\n     * const pd_b:any = ((<any>ctx.doSomething($event)) !== false);\n     * return pd_b;\n     * ```\n     *\n     * but render2 expects:\n     * ```\n     * return ctx.doSomething($event);\n     * ```\n     */\n    // TODO(misko): remove this hack once we no longer support ViewEngine.\n    this.render3Stmts = stmts.map((statement: o.Statement) => {\n      if (statement instanceof o.DeclareVarStmt && statement.name == allowDefault.name &&\n          statement.value instanceof o.BinaryOperatorExpr) {\n        const lhs = statement.value.lhs as o.CastExpr;\n        return new o.ReturnStatement(lhs.value);\n      }\n      return statement;\n    });\n  }\n}\n\nexport type InterpolationFunction = (args: o.Expression[]) => o.Expression;\n\n/**\n * Converts the given expression AST into an executable output AST, assuming the expression is\n * used in an action binding (e.g. an event handler).\n */\nexport function convertActionBinding(\n    localResolver: LocalResolver | null, implicitReceiver: o.Expression, action: cdAst.AST,\n    bindingId: string, interpolationFunction?: InterpolationFunction): ConvertActionBindingResult {\n  if (!localResolver) {\n    localResolver = new DefaultLocalResolver();\n  }\n  const actionWithoutBuiltins = convertPropertyBindingBuiltins(\n      {\n        createLiteralArrayConverter: (argCount: number) => {\n          // Note: no caching for literal arrays in actions.\n          return (args: o.Expression[]) => o.literalArr(args);\n        },\n        createLiteralMapConverter: (keys: {key: string, quoted: boolean}[]) => {\n          // Note: no caching for literal maps in actions.\n          return (values: o.Expression[]) => {\n            const entries = keys.map((k, i) => ({\n                                       key: k.key,\n                                       value: values[i],\n                                       quoted: k.quoted,\n                                     }));\n            return o.literalMap(entries);\n          };\n        },\n        createPipeConverter: (name: string) => {\n          throw new Error(`Illegal State: Actions are not allowed to contain pipes. Pipe: ${name}`);\n        }\n      },\n      action);\n\n  const visitor =\n      new _AstToIrVisitor(localResolver, implicitReceiver, bindingId, interpolationFunction);\n  const actionStmts: o.Statement[] = [];\n  flattenStatements(actionWithoutBuiltins.visit(visitor, _Mode.Statement), actionStmts);\n  prependTemporaryDecls(visitor.temporaryCount, bindingId, actionStmts);\n  const lastIndex = actionStmts.length - 1;\n  let preventDefaultVar: o.ReadVarExpr = null !;\n  if (lastIndex >= 0) {\n    const lastStatement = actionStmts[lastIndex];\n    const returnExpr = convertStmtIntoExpression(lastStatement);\n    if (returnExpr) {\n      // Note: We need to cast the result of the method call to dynamic,\n      // as it might be a void method!\n      preventDefaultVar = createPreventDefaultVar(bindingId);\n      actionStmts[lastIndex] =\n          preventDefaultVar.set(returnExpr.cast(o.DYNAMIC_TYPE).notIdentical(o.literal(false)))\n              .toDeclStmt(null, [o.StmtModifier.Final]);\n    }\n  }\n  return new ConvertActionBindingResult(actionStmts, preventDefaultVar);\n}\n\nexport interface BuiltinConverter { (args: o.Expression[]): o.Expression; }\n\nexport interface BuiltinConverterFactory {\n  createLiteralArrayConverter(argCount: number): BuiltinConverter;\n  createLiteralMapConverter(keys: {key: string, quoted: boolean}[]): BuiltinConverter;\n  createPipeConverter(name: string, argCount: number): BuiltinConverter;\n}\n\nexport function convertPropertyBindingBuiltins(\n    converterFactory: BuiltinConverterFactory, ast: cdAst.AST): cdAst.AST {\n  return convertBuiltins(converterFactory, ast);\n}\n\nexport class ConvertPropertyBindingResult {\n  constructor(public stmts: o.Statement[], public currValExpr: o.Expression) {}\n}\n\nexport enum BindingForm {\n  // The general form of binding expression, supports all expressions.\n  General,\n\n  // Try to generate a simple binding (no temporaries or statements)\n  // otherwise generate a general binding\n  TrySimple,\n}\n\n/**\n * Converts the given expression AST into an executable output AST, assuming the expression\n * is used in property binding. The expression has to be preprocessed via\n * `convertPropertyBindingBuiltins`.\n */\nexport function convertPropertyBinding(\n    localResolver: LocalResolver | null, implicitReceiver: o.Expression,\n    expressionWithoutBuiltins: cdAst.AST, bindingId: string, form: BindingForm,\n    interpolationFunction?: InterpolationFunction): ConvertPropertyBindingResult {\n  if (!localResolver) {\n    localResolver = new DefaultLocalResolver();\n  }\n  const currValExpr = createCurrValueExpr(bindingId);\n  const stmts: o.Statement[] = [];\n  const visitor =\n      new _AstToIrVisitor(localResolver, implicitReceiver, bindingId, interpolationFunction);\n  const outputExpr: o.Expression = expressionWithoutBuiltins.visit(visitor, _Mode.Expression);\n\n  if (visitor.temporaryCount) {\n    for (let i = 0; i < visitor.temporaryCount; i++) {\n      stmts.push(temporaryDeclaration(bindingId, i));\n    }\n  } else if (form == BindingForm.TrySimple) {\n    return new ConvertPropertyBindingResult([], outputExpr);\n  }\n\n  stmts.push(currValExpr.set(outputExpr).toDeclStmt(o.DYNAMIC_TYPE, [o.StmtModifier.Final]));\n  return new ConvertPropertyBindingResult(stmts, currValExpr);\n}\n\nfunction convertBuiltins(converterFactory: BuiltinConverterFactory, ast: cdAst.AST): cdAst.AST {\n  const visitor = new _BuiltinAstConverter(converterFactory);\n  return ast.visit(visitor);\n}\n\nfunction temporaryName(bindingId: string, temporaryNumber: number): string {\n  return `tmp_${bindingId}_${temporaryNumber}`;\n}\n\nexport function temporaryDeclaration(bindingId: string, temporaryNumber: number): o.Statement {\n  return new o.DeclareVarStmt(temporaryName(bindingId, temporaryNumber), o.NULL_EXPR);\n}\n\nfunction prependTemporaryDecls(\n    temporaryCount: number, bindingId: string, statements: o.Statement[]) {\n  for (let i = temporaryCount - 1; i >= 0; i--) {\n    statements.unshift(temporaryDeclaration(bindingId, i));\n  }\n}\n\nenum _Mode {\n  Statement,\n  Expression\n}\n\nfunction ensureStatementMode(mode: _Mode, ast: cdAst.AST) {\n  if (mode !== _Mode.Statement) {\n    throw new Error(`Expected a statement, but saw ${ast}`);\n  }\n}\n\nfunction ensureExpressionMode(mode: _Mode, ast: cdAst.AST) {\n  if (mode !== _Mode.Expression) {\n    throw new Error(`Expected an expression, but saw ${ast}`);\n  }\n}\n\nfunction convertToStatementIfNeeded(mode: _Mode, expr: o.Expression): o.Expression|o.Statement {\n  if (mode === _Mode.Statement) {\n    return expr.toStmt();\n  } else {\n    return expr;\n  }\n}\n\nclass _BuiltinAstConverter extends cdAst.AstTransformer {\n  constructor(private _converterFactory: BuiltinConverterFactory) { super(); }\n  visitPipe(ast: cdAst.BindingPipe, context: any): any {\n    const args = [ast.exp, ...ast.args].map(ast => ast.visit(this, context));\n    return new BuiltinFunctionCall(\n        ast.span, args, this._converterFactory.createPipeConverter(ast.name, args.length));\n  }\n  visitLiteralArray(ast: cdAst.LiteralArray, context: any): any {\n    const args = ast.expressions.map(ast => ast.visit(this, context));\n    return new BuiltinFunctionCall(\n        ast.span, args, this._converterFactory.createLiteralArrayConverter(ast.expressions.length));\n  }\n  visitLiteralMap(ast: cdAst.LiteralMap, context: any): any {\n    const args = ast.values.map(ast => ast.visit(this, context));\n\n    return new BuiltinFunctionCall(\n        ast.span, args, this._converterFactory.createLiteralMapConverter(ast.keys));\n  }\n}\n\nclass _AstToIrVisitor implements cdAst.AstVisitor {\n  private _nodeMap = new Map<cdAst.AST, cdAst.AST>();\n  private _resultMap = new Map<cdAst.AST, o.Expression>();\n  private _currentTemporary: number = 0;\n  public temporaryCount: number = 0;\n\n  constructor(\n      private _localResolver: LocalResolver, private _implicitReceiver: o.Expression,\n      private bindingId: string, private interpolationFunction: InterpolationFunction|undefined) {}\n\n  visitBinary(ast: cdAst.Binary, mode: _Mode): any {\n    let op: o.BinaryOperator;\n    switch (ast.operation) {\n      case '+':\n        op = o.BinaryOperator.Plus;\n        break;\n      case '-':\n        op = o.BinaryOperator.Minus;\n        break;\n      case '*':\n        op = o.BinaryOperator.Multiply;\n        break;\n      case '/':\n        op = o.BinaryOperator.Divide;\n        break;\n      case '%':\n        op = o.BinaryOperator.Modulo;\n        break;\n      case '&&':\n        op = o.BinaryOperator.And;\n        break;\n      case '||':\n        op = o.BinaryOperator.Or;\n        break;\n      case '==':\n        op = o.BinaryOperator.Equals;\n        break;\n      case '!=':\n        op = o.BinaryOperator.NotEquals;\n        break;\n      case '===':\n        op = o.BinaryOperator.Identical;\n        break;\n      case '!==':\n        op = o.BinaryOperator.NotIdentical;\n        break;\n      case '<':\n        op = o.BinaryOperator.Lower;\n        break;\n      case '>':\n        op = o.BinaryOperator.Bigger;\n        break;\n      case '<=':\n        op = o.BinaryOperator.LowerEquals;\n        break;\n      case '>=':\n        op = o.BinaryOperator.BiggerEquals;\n        break;\n      default:\n        throw new Error(`Unsupported operation ${ast.operation}`);\n    }\n\n    return convertToStatementIfNeeded(\n        mode,\n        new o.BinaryOperatorExpr(\n            op, this._visit(ast.left, _Mode.Expression), this._visit(ast.right, _Mode.Expression)));\n  }\n\n  visitChain(ast: cdAst.Chain, mode: _Mode): any {\n    ensureStatementMode(mode, ast);\n    return this.visitAll(ast.expressions, mode);\n  }\n\n  visitConditional(ast: cdAst.Conditional, mode: _Mode): any {\n    const value: o.Expression = this._visit(ast.condition, _Mode.Expression);\n    return convertToStatementIfNeeded(\n        mode, value.conditional(\n                  this._visit(ast.trueExp, _Mode.Expression),\n                  this._visit(ast.falseExp, _Mode.Expression)));\n  }\n\n  visitPipe(ast: cdAst.BindingPipe, mode: _Mode): any {\n    throw new Error(\n        `Illegal state: Pipes should have been converted into functions. Pipe: ${ast.name}`);\n  }\n\n  visitFunctionCall(ast: cdAst.FunctionCall, mode: _Mode): any {\n    const convertedArgs = this.visitAll(ast.args, _Mode.Expression);\n    let fnResult: o.Expression;\n    if (ast instanceof BuiltinFunctionCall) {\n      fnResult = ast.converter(convertedArgs);\n    } else {\n      fnResult = this._visit(ast.target !, _Mode.Expression).callFn(convertedArgs);\n    }\n    return convertToStatementIfNeeded(mode, fnResult);\n  }\n\n  visitImplicitReceiver(ast: cdAst.ImplicitReceiver, mode: _Mode): any {\n    ensureExpressionMode(mode, ast);\n    return this._implicitReceiver;\n  }\n\n  visitInterpolation(ast: cdAst.Interpolation, mode: _Mode): any {\n    ensureExpressionMode(mode, ast);\n    const args = [o.literal(ast.expressions.length)];\n    for (let i = 0; i < ast.strings.length - 1; i++) {\n      args.push(o.literal(ast.strings[i]));\n      args.push(this._visit(ast.expressions[i], _Mode.Expression));\n    }\n    args.push(o.literal(ast.strings[ast.strings.length - 1]));\n\n    if (this.interpolationFunction) {\n      return this.interpolationFunction(args);\n    }\n    return ast.expressions.length <= 9 ?\n        o.importExpr(Identifiers.inlineInterpolate).callFn(args) :\n        o.importExpr(Identifiers.interpolate).callFn([args[0], o.literalArr(args.slice(1))]);\n  }\n\n  visitKeyedRead(ast: cdAst.KeyedRead, mode: _Mode): any {\n    const leftMostSafe = this.leftMostSafeNode(ast);\n    if (leftMostSafe) {\n      return this.convertSafeAccess(ast, leftMostSafe, mode);\n    } else {\n      return convertToStatementIfNeeded(\n          mode, this._visit(ast.obj, _Mode.Expression).key(this._visit(ast.key, _Mode.Expression)));\n    }\n  }\n\n  visitKeyedWrite(ast: cdAst.KeyedWrite, mode: _Mode): any {\n    const obj: o.Expression = this._visit(ast.obj, _Mode.Expression);\n    const key: o.Expression = this._visit(ast.key, _Mode.Expression);\n    const value: o.Expression = this._visit(ast.value, _Mode.Expression);\n    return convertToStatementIfNeeded(mode, obj.key(key).set(value));\n  }\n\n  visitLiteralArray(ast: cdAst.LiteralArray, mode: _Mode): any {\n    throw new Error(`Illegal State: literal arrays should have been converted into functions`);\n  }\n\n  visitLiteralMap(ast: cdAst.LiteralMap, mode: _Mode): any {\n    throw new Error(`Illegal State: literal maps should have been converted into functions`);\n  }\n\n  visitLiteralPrimitive(ast: cdAst.LiteralPrimitive, mode: _Mode): any {\n    // For literal values of null, undefined, true, or false allow type interference\n    // to infer the type.\n    const type =\n        ast.value === null || ast.value === undefined || ast.value === true || ast.value === true ?\n        o.INFERRED_TYPE :\n        undefined;\n    return convertToStatementIfNeeded(mode, o.literal(ast.value, type));\n  }\n\n  private _getLocal(name: string): o.Expression|null { return this._localResolver.getLocal(name); }\n\n  visitMethodCall(ast: cdAst.MethodCall, mode: _Mode): any {\n    if (ast.receiver instanceof cdAst.ImplicitReceiver && ast.name == '$any') {\n      const args = this.visitAll(ast.args, _Mode.Expression) as any[];\n      if (args.length != 1) {\n        throw new Error(\n            `Invalid call to $any, expected 1 argument but received ${args.length || 'none'}`);\n      }\n      return (args[0] as o.Expression).cast(o.DYNAMIC_TYPE);\n    }\n\n    const leftMostSafe = this.leftMostSafeNode(ast);\n    if (leftMostSafe) {\n      return this.convertSafeAccess(ast, leftMostSafe, mode);\n    } else {\n      const args = this.visitAll(ast.args, _Mode.Expression);\n      let result: any = null;\n      const receiver = this._visit(ast.receiver, _Mode.Expression);\n      if (receiver === this._implicitReceiver) {\n        const varExpr = this._getLocal(ast.name);\n        if (varExpr) {\n          result = varExpr.callFn(args);\n        }\n      }\n      if (result == null) {\n        result = receiver.callMethod(ast.name, args);\n      }\n      return convertToStatementIfNeeded(mode, result);\n    }\n  }\n\n  visitPrefixNot(ast: cdAst.PrefixNot, mode: _Mode): any {\n    return convertToStatementIfNeeded(mode, o.not(this._visit(ast.expression, _Mode.Expression)));\n  }\n\n  visitNonNullAssert(ast: cdAst.NonNullAssert, mode: _Mode): any {\n    return convertToStatementIfNeeded(\n        mode, o.assertNotNull(this._visit(ast.expression, _Mode.Expression)));\n  }\n\n  visitPropertyRead(ast: cdAst.PropertyRead, mode: _Mode): any {\n    const leftMostSafe = this.leftMostSafeNode(ast);\n    if (leftMostSafe) {\n      return this.convertSafeAccess(ast, leftMostSafe, mode);\n    } else {\n      let result: any = null;\n      const receiver = this._visit(ast.receiver, _Mode.Expression);\n      if (receiver === this._implicitReceiver) {\n        result = this._getLocal(ast.name);\n      }\n      if (result == null) {\n        result = receiver.prop(ast.name);\n      }\n      return convertToStatementIfNeeded(mode, result);\n    }\n  }\n\n  visitPropertyWrite(ast: cdAst.PropertyWrite, mode: _Mode): any {\n    const receiver: o.Expression = this._visit(ast.receiver, _Mode.Expression);\n\n    let varExpr: o.ReadPropExpr|null = null;\n    if (receiver === this._implicitReceiver) {\n      const localExpr = this._getLocal(ast.name);\n      if (localExpr) {\n        if (localExpr instanceof o.ReadPropExpr) {\n          // If the local variable is a property read expression, it's a reference\n          // to a 'context.property' value and will be used as the target of the\n          // write expression.\n          varExpr = localExpr;\n        } else {\n          // Otherwise it's an error.\n          throw new Error('Cannot assign to a reference or variable!');\n        }\n      }\n    }\n    // If no local expression could be produced, use the original receiver's\n    // property as the target.\n    if (varExpr === null) {\n      varExpr = receiver.prop(ast.name);\n    }\n    return convertToStatementIfNeeded(mode, varExpr.set(this._visit(ast.value, _Mode.Expression)));\n  }\n\n  visitSafePropertyRead(ast: cdAst.SafePropertyRead, mode: _Mode): any {\n    return this.convertSafeAccess(ast, this.leftMostSafeNode(ast), mode);\n  }\n\n  visitSafeMethodCall(ast: cdAst.SafeMethodCall, mode: _Mode): any {\n    return this.convertSafeAccess(ast, this.leftMostSafeNode(ast), mode);\n  }\n\n  visitAll(asts: cdAst.AST[], mode: _Mode): any { return asts.map(ast => this._visit(ast, mode)); }\n\n  visitQuote(ast: cdAst.Quote, mode: _Mode): any {\n    throw new Error(`Quotes are not supported for evaluation!\n        Statement: ${ast.uninterpretedExpression} located at ${ast.location}`);\n  }\n\n  private _visit(ast: cdAst.AST, mode: _Mode): any {\n    const result = this._resultMap.get(ast);\n    if (result) return result;\n    return (this._nodeMap.get(ast) || ast).visit(this, mode);\n  }\n\n  private convertSafeAccess(\n      ast: cdAst.AST, leftMostSafe: cdAst.SafeMethodCall|cdAst.SafePropertyRead, mode: _Mode): any {\n    // If the expression contains a safe access node on the left it needs to be converted to\n    // an expression that guards the access to the member by checking the receiver for blank. As\n    // execution proceeds from left to right, the left most part of the expression must be guarded\n    // first but, because member access is left associative, the right side of the expression is at\n    // the top of the AST. The desired result requires lifting a copy of the the left part of the\n    // expression up to test it for blank before generating the unguarded version.\n\n    // Consider, for example the following expression: a?.b.c?.d.e\n\n    // This results in the ast:\n    //         .\n    //        / \\\n    //       ?.   e\n    //      /  \\\n    //     .    d\n    //    / \\\n    //   ?.  c\n    //  /  \\\n    // a    b\n\n    // The following tree should be generated:\n    //\n    //        /---- ? ----\\\n    //       /      |      \\\n    //     a   /--- ? ---\\  null\n    //        /     |     \\\n    //       .      .     null\n    //      / \\    / \\\n    //     .  c   .   e\n    //    / \\    / \\\n    //   a   b  ,   d\n    //         / \\\n    //        .   c\n    //       / \\\n    //      a   b\n    //\n    // Notice that the first guard condition is the left hand of the left most safe access node\n    // which comes in as leftMostSafe to this routine.\n\n    let guardedExpression = this._visit(leftMostSafe.receiver, _Mode.Expression);\n    let temporary: o.ReadVarExpr = undefined !;\n    if (this.needsTemporary(leftMostSafe.receiver)) {\n      // If the expression has method calls or pipes then we need to save the result into a\n      // temporary variable to avoid calling stateful or impure code more than once.\n      temporary = this.allocateTemporary();\n\n      // Preserve the result in the temporary variable\n      guardedExpression = temporary.set(guardedExpression);\n\n      // Ensure all further references to the guarded expression refer to the temporary instead.\n      this._resultMap.set(leftMostSafe.receiver, temporary);\n    }\n    const condition = guardedExpression.isBlank();\n\n    // Convert the ast to an unguarded access to the receiver's member. The map will substitute\n    // leftMostNode with its unguarded version in the call to `this.visit()`.\n    if (leftMostSafe instanceof cdAst.SafeMethodCall) {\n      this._nodeMap.set(\n          leftMostSafe,\n          new cdAst.MethodCall(\n              leftMostSafe.span, leftMostSafe.receiver, leftMostSafe.name, leftMostSafe.args));\n    } else {\n      this._nodeMap.set(\n          leftMostSafe,\n          new cdAst.PropertyRead(leftMostSafe.span, leftMostSafe.receiver, leftMostSafe.name));\n    }\n\n    // Recursively convert the node now without the guarded member access.\n    const access = this._visit(ast, _Mode.Expression);\n\n    // Remove the mapping. This is not strictly required as the converter only traverses each node\n    // once but is safer if the conversion is changed to traverse the nodes more than once.\n    this._nodeMap.delete(leftMostSafe);\n\n    // If we allocated a temporary, release it.\n    if (temporary) {\n      this.releaseTemporary(temporary);\n    }\n\n    // Produce the conditional\n    return convertToStatementIfNeeded(mode, condition.conditional(o.literal(null), access));\n  }\n\n  // Given a expression of the form a?.b.c?.d.e the the left most safe node is\n  // the (a?.b). The . and ?. are left associative thus can be rewritten as:\n  // ((((a?.c).b).c)?.d).e. This returns the most deeply nested safe read or\n  // safe method call as this needs be transform initially to:\n  //   a == null ? null : a.c.b.c?.d.e\n  // then to:\n  //   a == null ? null : a.b.c == null ? null : a.b.c.d.e\n  private leftMostSafeNode(ast: cdAst.AST): cdAst.SafePropertyRead|cdAst.SafeMethodCall {\n    const visit = (visitor: cdAst.AstVisitor, ast: cdAst.AST): any => {\n      return (this._nodeMap.get(ast) || ast).visit(visitor);\n    };\n    return ast.visit({\n      visitBinary(ast: cdAst.Binary) { return null; },\n      visitChain(ast: cdAst.Chain) { return null; },\n      visitConditional(ast: cdAst.Conditional) { return null; },\n      visitFunctionCall(ast: cdAst.FunctionCall) { return null; },\n      visitImplicitReceiver(ast: cdAst.ImplicitReceiver) { return null; },\n      visitInterpolation(ast: cdAst.Interpolation) { return null; },\n      visitKeyedRead(ast: cdAst.KeyedRead) { return visit(this, ast.obj); },\n      visitKeyedWrite(ast: cdAst.KeyedWrite) { return null; },\n      visitLiteralArray(ast: cdAst.LiteralArray) { return null; },\n      visitLiteralMap(ast: cdAst.LiteralMap) { return null; },\n      visitLiteralPrimitive(ast: cdAst.LiteralPrimitive) { return null; },\n      visitMethodCall(ast: cdAst.MethodCall) { return visit(this, ast.receiver); },\n      visitPipe(ast: cdAst.BindingPipe) { return null; },\n      visitPrefixNot(ast: cdAst.PrefixNot) { return null; },\n      visitNonNullAssert(ast: cdAst.NonNullAssert) { return null; },\n      visitPropertyRead(ast: cdAst.PropertyRead) { return visit(this, ast.receiver); },\n      visitPropertyWrite(ast: cdAst.PropertyWrite) { return null; },\n      visitQuote(ast: cdAst.Quote) { return null; },\n      visitSafeMethodCall(ast: cdAst.SafeMethodCall) { return visit(this, ast.receiver) || ast; },\n      visitSafePropertyRead(ast: cdAst.SafePropertyRead) {\n        return visit(this, ast.receiver) || ast;\n      }\n    });\n  }\n\n  // Returns true of the AST includes a method or a pipe indicating that, if the\n  // expression is used as the target of a safe property or method access then\n  // the expression should be stored into a temporary variable.\n  private needsTemporary(ast: cdAst.AST): boolean {\n    const visit = (visitor: cdAst.AstVisitor, ast: cdAst.AST): boolean => {\n      return ast && (this._nodeMap.get(ast) || ast).visit(visitor);\n    };\n    const visitSome = (visitor: cdAst.AstVisitor, ast: cdAst.AST[]): boolean => {\n      return ast.some(ast => visit(visitor, ast));\n    };\n    return ast.visit({\n      visitBinary(ast: cdAst.Binary):\n          boolean{return visit(this, ast.left) || visit(this, ast.right);},\n      visitChain(ast: cdAst.Chain) { return false; },\n      visitConditional(ast: cdAst.Conditional):\n          boolean{return visit(this, ast.condition) || visit(this, ast.trueExp) ||\n                      visit(this, ast.falseExp);},\n      visitFunctionCall(ast: cdAst.FunctionCall) { return true; },\n      visitImplicitReceiver(ast: cdAst.ImplicitReceiver) { return false; },\n      visitInterpolation(ast: cdAst.Interpolation) { return visitSome(this, ast.expressions); },\n      visitKeyedRead(ast: cdAst.KeyedRead) { return false; },\n      visitKeyedWrite(ast: cdAst.KeyedWrite) { return false; },\n      visitLiteralArray(ast: cdAst.LiteralArray) { return true; },\n      visitLiteralMap(ast: cdAst.LiteralMap) { return true; },\n      visitLiteralPrimitive(ast: cdAst.LiteralPrimitive) { return false; },\n      visitMethodCall(ast: cdAst.MethodCall) { return true; },\n      visitPipe(ast: cdAst.BindingPipe) { return true; },\n      visitPrefixNot(ast: cdAst.PrefixNot) { return visit(this, ast.expression); },\n      visitNonNullAssert(ast: cdAst.PrefixNot) { return visit(this, ast.expression); },\n      visitPropertyRead(ast: cdAst.PropertyRead) { return false; },\n      visitPropertyWrite(ast: cdAst.PropertyWrite) { return false; },\n      visitQuote(ast: cdAst.Quote) { return false; },\n      visitSafeMethodCall(ast: cdAst.SafeMethodCall) { return true; },\n      visitSafePropertyRead(ast: cdAst.SafePropertyRead) { return false; }\n    });\n  }\n\n  private allocateTemporary(): o.ReadVarExpr {\n    const tempNumber = this._currentTemporary++;\n    this.temporaryCount = Math.max(this._currentTemporary, this.temporaryCount);\n    return new o.ReadVarExpr(temporaryName(this.bindingId, tempNumber));\n  }\n\n  private releaseTemporary(temporary: o.ReadVarExpr) {\n    this._currentTemporary--;\n    if (temporary.name != temporaryName(this.bindingId, this._currentTemporary)) {\n      throw new Error(`Temporary ${temporary.name} released out of order`);\n    }\n  }\n}\n\nfunction flattenStatements(arg: any, output: o.Statement[]) {\n  if (Array.isArray(arg)) {\n    (<any[]>arg).forEach((entry) => flattenStatements(entry, output));\n  } else {\n    output.push(arg);\n  }\n}\n\nclass DefaultLocalResolver implements LocalResolver {\n  getLocal(name: string): o.Expression|null {\n    if (name === EventHandlerVars.event.name) {\n      return EventHandlerVars.event;\n    }\n    return null;\n  }\n}\n\nfunction createCurrValueExpr(bindingId: string): o.ReadVarExpr {\n  return o.variable(`currVal_${bindingId}`);  // fix syntax highlighting: `\n}\n\nfunction createPreventDefaultVar(bindingId: string): o.ReadVarExpr {\n  return o.variable(`pd_${bindingId}`);\n}\n\nfunction convertStmtIntoExpression(stmt: o.Statement): o.Expression|null {\n  if (stmt instanceof o.ExpressionStatement) {\n    return stmt.expr;\n  } else if (stmt instanceof o.ReturnStatement) {\n    return stmt.value;\n  }\n  return null;\n}\n\nexport class BuiltinFunctionCall extends cdAst.FunctionCall {\n  constructor(span: cdAst.ParseSpan, public args: cdAst.AST[], public converter: BuiltinConverter) {\n    super(span, null, args);\n  }\n}\n"]}