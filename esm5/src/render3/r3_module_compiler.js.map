{"version":3,"file":"r3_module_compiler.js","sourceRoot":"","sources":["../../../../../../packages/compiler/src/render3/r3_module_compiler.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {CompileShallowModuleMetadata, identifierName} from '../compile_metadata';\nimport {InjectableCompiler} from '../injectable_compiler';\nimport {mapLiteral} from '../output/map_util';\nimport * as o from '../output/output_ast';\nimport {OutputContext} from '../util';\n\nimport {R3DependencyMetadata, compileFactoryFunction} from './r3_factory';\nimport {Identifiers as R3} from './r3_identifiers';\nimport {R3Reference, convertMetaToOutput, mapToMapExpression} from './util';\n\nexport interface R3NgModuleDef {\n  expression: o.Expression;\n  type: o.Type;\n  additionalStatements: o.Statement[];\n}\n\n/**\n * Metadata required by the module compiler to generate a `ngModuleDef` for a type.\n */\nexport interface R3NgModuleMetadata {\n  /**\n   * An expression representing the module type being compiled.\n   */\n  type: o.Expression;\n\n  /**\n   * An array of expressions representing the bootstrap components specified by the module.\n   */\n  bootstrap: R3Reference[];\n\n  /**\n   * An array of expressions representing the directives and pipes declared by the module.\n   */\n  declarations: R3Reference[];\n\n  /**\n   * An array of expressions representing the imports of the module.\n   */\n  imports: R3Reference[];\n\n  /**\n   * An array of expressions representing the exports of the module.\n   */\n  exports: R3Reference[];\n\n  /**\n   * Whether to emit the selector scope values (declarations, imports, exports) inline into the\n   * module definition, or to generate additional statements which patch them on. Inline emission\n   * does not allow components to be tree-shaken, but is useful for JIT mode.\n   */\n  emitInline: boolean;\n}\n\n/**\n * Construct an `R3NgModuleDef` for the given `R3NgModuleMetadata`.\n */\nexport function compileNgModule(meta: R3NgModuleMetadata): R3NgModuleDef {\n  const {type: moduleType, bootstrap, declarations, imports, exports} = meta;\n  const expression = o.importExpr(R3.defineNgModule).callFn([mapToMapExpression({\n    type: moduleType,\n    bootstrap: o.literalArr(bootstrap.map(ref => ref.value)),\n    declarations: o.literalArr(declarations.map(ref => ref.value)),\n    imports: o.literalArr(imports.map(ref => ref.value)),\n    exports: o.literalArr(exports.map(ref => ref.value)),\n  })]);\n\n  const type = new o.ExpressionType(o.importExpr(R3.NgModuleDefWithMeta, [\n    new o.ExpressionType(moduleType), tupleTypeOf(declarations), tupleTypeOf(imports),\n    tupleTypeOf(exports)\n  ]));\n\n  const additionalStatements: o.Statement[] = [];\n  return {expression, type, additionalStatements};\n}\n\nexport interface R3InjectorDef {\n  expression: o.Expression;\n  type: o.Type;\n  statements: o.Statement[];\n}\n\nexport interface R3InjectorMetadata {\n  name: string;\n  type: o.Expression;\n  deps: R3DependencyMetadata[]|null;\n  providers: o.Expression;\n  imports: o.Expression;\n}\n\nexport function compileInjector(meta: R3InjectorMetadata): R3InjectorDef {\n  const result = compileFactoryFunction({\n    name: meta.name,\n    type: meta.type,\n    deps: meta.deps,\n    injectFn: R3.inject,\n    extraStatementFn: null,\n  });\n  const expression = o.importExpr(R3.defineInjector).callFn([mapToMapExpression({\n    factory: result.factory,\n    providers: meta.providers,\n    imports: meta.imports,\n  })]);\n  const type =\n      new o.ExpressionType(o.importExpr(R3.InjectorDef, [new o.ExpressionType(meta.type)]));\n  return {expression, type, statements: result.statements};\n}\n\n// TODO(alxhub): integrate this with `compileNgModule`. Currently the two are separate operations.\nexport function compileNgModuleFromRender2(\n    ctx: OutputContext, ngModule: CompileShallowModuleMetadata,\n    injectableCompiler: InjectableCompiler): void {\n  const className = identifierName(ngModule.type) !;\n\n  const rawImports = ngModule.rawImports ? [ngModule.rawImports] : [];\n  const rawExports = ngModule.rawExports ? [ngModule.rawExports] : [];\n\n  const injectorDefArg = mapLiteral({\n    'factory':\n        injectableCompiler.factoryFor({type: ngModule.type, symbol: ngModule.type.reference}, ctx),\n    'providers': convertMetaToOutput(ngModule.rawProviders, ctx),\n    'imports': convertMetaToOutput([...rawImports, ...rawExports], ctx),\n  });\n\n  const injectorDef = o.importExpr(R3.defineInjector).callFn([injectorDefArg]);\n\n  ctx.statements.push(new o.ClassStmt(\n      /* name */ className,\n      /* parent */ null,\n      /* fields */[new o.ClassField(\n          /* name */ 'ngInjectorDef',\n          /* type */ o.INFERRED_TYPE,\n          /* modifiers */[o.StmtModifier.Static],\n          /* initializer */ injectorDef, )],\n      /* getters */[],\n      /* constructorMethod */ new o.ClassMethod(null, [], []),\n      /* methods */[]));\n}\n\nfunction accessExportScope(module: o.Expression): o.Expression {\n  const selectorScope = new o.ReadPropExpr(module, 'ngModuleDef');\n  return new o.ReadPropExpr(selectorScope, 'exported');\n}\n\nfunction tupleTypeOf(exp: R3Reference[]): o.Type {\n  const types = exp.map(ref => o.typeofExpr(ref.type));\n  return exp.length > 0 ? o.expressionType(o.literalArr(types)) : o.NONE_TYPE;\n}\n"]}