{"version":3,"file":"r3_factory.js","sourceRoot":"","sources":["../../../../../../packages/compiler/src/render3/r3_factory.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {StaticSymbol} from '../aot/static_symbol';\nimport {CompileTypeMetadata, tokenReference} from '../compile_metadata';\nimport {CompileReflector} from '../compile_reflector';\nimport {InjectFlags} from '../core';\nimport {Identifiers} from '../identifiers';\nimport * as o from '../output/output_ast';\nimport {Identifiers as R3} from '../render3/r3_identifiers';\nimport {OutputContext} from '../util';\n\nimport {unsupported} from './view/util';\n\n\n/**\n * Metadata required by the factory generator to generate a `factory` function for a type.\n */\nexport interface R3ConstructorFactoryMetadata {\n  /**\n   * String name of the type being generated (used to name the factory function).\n   */\n  name: string;\n\n  /**\n   * An expression representing the function (or constructor) which will instantiate the requested\n   * type.\n   *\n   * This could be a reference to a constructor type, or to a user-defined factory function. The\n   * `useNew` property determines whether it will be called as a constructor or not.\n   */\n  type: o.Expression;\n\n  /**\n   * Regardless of whether `fnOrClass` is a constructor function or a user-defined factory, it\n   * may have 0 or more parameters, which will be injected according to the `R3DependencyMetadata`\n   * for those parameters. If this is `null`, then the type's constructor is nonexistent and will\n   * be inherited from `fnOrClass` which is interpreted as the current type.\n   */\n  deps: R3DependencyMetadata[]|null;\n\n  /**\n   * An expression for the function which will be used to inject dependencies. The API of this\n   * function could be different, and other options control how it will be invoked.\n   */\n  injectFn: o.ExternalReference;\n\n  /**\n   * Function that allows extra statements to be inserted into factory function.\n   */\n  extraStatementFn: ((instance: o.Expression) => o.Statement[])|null;\n}\n\nexport enum R3FactoryDelegateType {\n  Class,\n  Function,\n  Factory,\n}\n\nexport interface R3DelegatedFactoryMetadata extends R3ConstructorFactoryMetadata {\n  delegate: o.Expression;\n  delegateType: R3FactoryDelegateType.Factory;\n}\n\nexport interface R3DelegatedFnOrClassMetadata extends R3ConstructorFactoryMetadata {\n  delegate: o.Expression;\n  delegateType: R3FactoryDelegateType.Class|R3FactoryDelegateType.Function;\n  delegateDeps: R3DependencyMetadata[];\n}\n\nexport interface R3ExpressionFactoryMetadata extends R3ConstructorFactoryMetadata {\n  expression: o.Expression;\n}\n\nexport type R3FactoryMetadata = R3ConstructorFactoryMetadata | R3DelegatedFactoryMetadata |\n    R3DelegatedFnOrClassMetadata | R3ExpressionFactoryMetadata;\n\n/**\n * Resolved type of a dependency.\n *\n * Occasionally, dependencies will have special significance which is known statically. In that\n * case the `R3ResolvedDependencyType` informs the factory generator that a particular dependency\n * should be generated specially (usually by calling a special injection function instead of the\n * standard one).\n */\nexport enum R3ResolvedDependencyType {\n  /**\n   * A normal token dependency.\n   */\n  Token = 0,\n\n  /**\n   * The dependency is for an attribute.\n   *\n   * The token expression is a string representing the attribute name.\n   */\n  Attribute = 1,\n}\n\n/**\n * Metadata representing a single dependency to be injected into a constructor or function call.\n */\nexport interface R3DependencyMetadata {\n  /**\n   * An expression representing the token or value to be injected.\n   */\n  token: o.Expression;\n\n  /**\n   * An enum indicating whether this dependency has special meaning to Angular and needs to be\n   * injected specially.\n   */\n  resolved: R3ResolvedDependencyType;\n\n  /**\n   * Whether the dependency has an @Host qualifier.\n   */\n  host: boolean;\n\n  /**\n   * Whether the dependency has an @Optional qualifier.\n   */\n  optional: boolean;\n\n  /**\n   * Whether the dependency has an @Self qualifier.\n   */\n  self: boolean;\n\n  /**\n   * Whether the dependency has an @SkipSelf qualifier.\n   */\n  skipSelf: boolean;\n}\n\n/**\n * Construct a factory function expression for the given `R3FactoryMetadata`.\n */\nexport function compileFactoryFunction(meta: R3FactoryMetadata):\n    {factory: o.Expression, statements: o.Statement[]} {\n  const t = o.variable('t');\n  const statements: o.Statement[] = [];\n\n  // The type to instantiate via constructor invocation. If there is no delegated factory, meaning\n  // this type is always created by constructor invocation, then this is the type-to-create\n  // parameter provided by the user (t) if specified, or the current type if not. If there is a\n  // delegated factory (which is used to create the current type) then this is only the type-to-\n  // create parameter (t).\n  const typeForCtor =\n      !isDelegatedMetadata(meta) ? new o.BinaryOperatorExpr(o.BinaryOperator.Or, t, meta.type) : t;\n\n  let ctorExpr: o.Expression|null = null;\n  if (meta.deps !== null) {\n    // There is a constructor (either explicitly or implicitly defined).\n    ctorExpr = new o.InstantiateExpr(typeForCtor, injectDependencies(meta.deps, meta.injectFn));\n  } else {\n    const baseFactory = o.variable(`ɵ${meta.name}_BaseFactory`);\n    const getInheritedFactory = o.importExpr(R3.getInheritedFactory);\n    const baseFactoryStmt =\n        baseFactory.set(getInheritedFactory.callFn([meta.type])).toDeclStmt(o.INFERRED_TYPE, [\n          o.StmtModifier.Exported, o.StmtModifier.Final\n        ]);\n    statements.push(baseFactoryStmt);\n\n    // There is no constructor, use the base class' factory to construct typeForCtor.\n    ctorExpr = baseFactory.callFn([typeForCtor]);\n  }\n  const ctorExprFinal = ctorExpr;\n\n  const body: o.Statement[] = [];\n  let retExpr: o.Expression|null = null;\n\n  function makeConditionalFactory(nonCtorExpr: o.Expression): o.ReadVarExpr {\n    const r = o.variable('r');\n    body.push(r.set(o.NULL_EXPR).toDeclStmt());\n    body.push(o.ifStmt(t, [r.set(ctorExprFinal).toStmt()], [r.set(nonCtorExpr).toStmt()]));\n    return r;\n  }\n\n  if (isDelegatedMetadata(meta) && meta.delegateType === R3FactoryDelegateType.Factory) {\n    const delegateFactory = o.variable(`ɵ${meta.name}_BaseFactory`);\n    const getFactoryOf = o.importExpr(R3.getFactoryOf);\n    if (meta.delegate.isEquivalent(meta.type)) {\n      throw new Error(`Illegal state: compiling factory that delegates to itself`);\n    }\n    const delegateFactoryStmt =\n        delegateFactory.set(getFactoryOf.callFn([meta.delegate])).toDeclStmt(o.INFERRED_TYPE, [\n          o.StmtModifier.Exported, o.StmtModifier.Final\n        ]);\n\n    statements.push(delegateFactoryStmt);\n    retExpr = makeConditionalFactory(delegateFactory.callFn([]));\n  } else if (isDelegatedMetadata(meta)) {\n    // This type is created with a delegated factory. If a type parameter is not specified, call\n    // the factory instead.\n    const delegateArgs = injectDependencies(meta.delegateDeps, meta.injectFn);\n    // Either call `new delegate(...)` or `delegate(...)` depending on meta.useNewForDelegate.\n    const factoryExpr = new (\n        meta.delegateType === R3FactoryDelegateType.Class ?\n            o.InstantiateExpr :\n            o.InvokeFunctionExpr)(meta.delegate, delegateArgs);\n    retExpr = makeConditionalFactory(factoryExpr);\n  } else if (isExpressionFactoryMetadata(meta)) {\n    // TODO(alxhub): decide whether to lower the value here or in the caller\n    retExpr = makeConditionalFactory(meta.expression);\n  } else if (meta.extraStatementFn) {\n    // if extraStatementsFn is specified and the 'makeConditionalFactory' function\n    // was not invoked, we need to create a reference to the instance, so we can\n    // pass it as an argument to the 'extraStatementFn' function while calling it\n    const variable = o.variable('f');\n    body.push(variable.set(ctorExpr).toDeclStmt());\n    retExpr = variable;\n  } else {\n    retExpr = ctorExpr;\n  }\n\n  if (meta.extraStatementFn) {\n    const extraStmts = meta.extraStatementFn(retExpr);\n    body.push(...extraStmts);\n  }\n\n  return {\n    factory: o.fn(\n        [new o.FnParam('t', o.DYNAMIC_TYPE)], [...body, new o.ReturnStatement(retExpr)],\n        o.INFERRED_TYPE, undefined, `${meta.name}_Factory`),\n    statements,\n  };\n}\n\nfunction injectDependencies(\n    deps: R3DependencyMetadata[], injectFn: o.ExternalReference): o.Expression[] {\n  return deps.map(dep => compileInjectDependency(dep, injectFn));\n}\n\nfunction compileInjectDependency(\n    dep: R3DependencyMetadata, injectFn: o.ExternalReference): o.Expression {\n  // Interpret the dependency according to its resolved type.\n  switch (dep.resolved) {\n    case R3ResolvedDependencyType.Token: {\n      // Build up the injection flags according to the metadata.\n      const flags = InjectFlags.Default | (dep.self ? InjectFlags.Self : 0) |\n          (dep.skipSelf ? InjectFlags.SkipSelf : 0) | (dep.host ? InjectFlags.Host : 0) |\n          (dep.optional ? InjectFlags.Optional : 0);\n\n      // Build up the arguments to the injectFn call.\n      const injectArgs = [dep.token];\n      // If this dependency is optional or otherwise has non-default flags, then additional\n      // parameters describing how to inject the dependency must be passed to the inject function\n      // that's being used.\n      if (flags !== InjectFlags.Default || dep.optional) {\n        injectArgs.push(o.literal(flags));\n      }\n      return o.importExpr(injectFn).callFn(injectArgs);\n    }\n    case R3ResolvedDependencyType.Attribute:\n      // In the case of attributes, the attribute name in question is given as the token.\n      return o.importExpr(R3.injectAttribute).callFn([dep.token]);\n    default:\n      return unsupported(\n          `Unknown R3ResolvedDependencyType: ${R3ResolvedDependencyType[dep.resolved]}`);\n  }\n}\n\n/**\n * A helper function useful for extracting `R3DependencyMetadata` from a Render2\n * `CompileTypeMetadata` instance.\n */\nexport function dependenciesFromGlobalMetadata(\n    type: CompileTypeMetadata, outputCtx: OutputContext,\n    reflector: CompileReflector): R3DependencyMetadata[] {\n  // Use the `CompileReflector` to look up references to some well-known Angular types. These will\n  // be compared with the token to statically determine whether the token has significance to\n  // Angular, and set the correct `R3ResolvedDependencyType` as a result.\n  const injectorRef = reflector.resolveExternalReference(Identifiers.Injector);\n\n  // Iterate through the type's DI dependencies and produce `R3DependencyMetadata` for each of them.\n  const deps: R3DependencyMetadata[] = [];\n  for (let dependency of type.diDeps) {\n    if (dependency.token) {\n      const tokenRef = tokenReference(dependency.token);\n      let resolved: R3ResolvedDependencyType = dependency.isAttribute ?\n          R3ResolvedDependencyType.Attribute :\n          R3ResolvedDependencyType.Token;\n\n      // In the case of most dependencies, the token will be a reference to a type. Sometimes,\n      // however, it can be a string, in the case of older Angular code or @Attribute injection.\n      const token =\n          tokenRef instanceof StaticSymbol ? outputCtx.importExpr(tokenRef) : o.literal(tokenRef);\n\n      // Construct the dependency.\n      deps.push({\n        token,\n        resolved,\n        host: !!dependency.isHost,\n        optional: !!dependency.isOptional,\n        self: !!dependency.isSelf,\n        skipSelf: !!dependency.isSkipSelf,\n      });\n    } else {\n      unsupported('dependency without a token');\n    }\n  }\n\n  return deps;\n}\n\nfunction isDelegatedMetadata(meta: R3FactoryMetadata): meta is R3DelegatedFactoryMetadata|\n    R3DelegatedFnOrClassMetadata {\n  return (meta as any).delegateType !== undefined;\n}\n\nfunction isExpressionFactoryMetadata(meta: R3FactoryMetadata): meta is R3ExpressionFactoryMetadata {\n  return (meta as any).expression !== undefined;\n}\n"]}