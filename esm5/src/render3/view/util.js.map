{"version":3,"file":"util.js","sourceRoot":"","sources":["../../../../../../../packages/compiler/src/render3/view/util.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ConstantPool} from '../../constant_pool';\nimport * as o from '../../output/output_ast';\nimport * as t from '../r3_ast';\n\nimport {R3QueryMetadata} from './api';\nimport {isI18NAttribute} from './i18n';\n\n/** Name of the temporary to use during data binding */\nexport const TEMPORARY_NAME = '_t';\n\n/** Name of the context parameter passed into a template function */\nexport const CONTEXT_NAME = 'ctx';\n\n/** Name of the RenderFlag passed into a template function */\nexport const RENDER_FLAGS = 'rf';\n\n/** The prefix reference variables */\nexport const REFERENCE_PREFIX = '_r';\n\n/** The name of the implicit context reference */\nexport const IMPLICIT_REFERENCE = '$implicit';\n\n/** Non bindable attribute name **/\nexport const NON_BINDABLE_ATTR = 'ngNonBindable';\n\n/**\n * Creates an allocator for a temporary variable.\n *\n * A variable declaration is added to the statements the first time the allocator is invoked.\n */\nexport function temporaryAllocator(statements: o.Statement[], name: string): () => o.ReadVarExpr {\n  let temp: o.ReadVarExpr|null = null;\n  return () => {\n    if (!temp) {\n      statements.push(new o.DeclareVarStmt(TEMPORARY_NAME, undefined, o.DYNAMIC_TYPE));\n      temp = o.variable(name);\n    }\n    return temp;\n  };\n}\n\n\nexport function unsupported(feature: string): never {\n  if (this) {\n    throw new Error(`Builder ${this.constructor.name} doesn't support ${feature} yet`);\n  }\n  throw new Error(`Feature ${feature} is not supported yet`);\n}\n\nexport function invalid<T>(arg: o.Expression | o.Statement | t.Node): never {\n  throw new Error(\n      `Invalid state: Visitor ${this.constructor.name} doesn't handle ${o.constructor.name}`);\n}\n\nexport function asLiteral(value: any): o.Expression {\n  if (Array.isArray(value)) {\n    return o.literalArr(value.map(asLiteral));\n  }\n  return o.literal(value, o.INFERRED_TYPE);\n}\n\nexport function conditionallyCreateMapObjectLiteral(keys: {[key: string]: string | string[]}):\n    o.Expression|null {\n  if (Object.getOwnPropertyNames(keys).length > 0) {\n    return mapToExpression(keys);\n  }\n  return null;\n}\n\nexport function mapToExpression(map: {[key: string]: any}, quoted = false): o.Expression {\n  return o.literalMap(\n      Object.getOwnPropertyNames(map).map(key => ({key, quoted, value: asLiteral(map[key])})));\n}\n\n/**\n *  Remove trailing null nodes as they are implied.\n */\nexport function trimTrailingNulls(parameters: o.Expression[]): o.Expression[] {\n  while (o.isNull(parameters[parameters.length - 1])) {\n    parameters.pop();\n  }\n  return parameters;\n}\n\nexport function getQueryPredicate(\n    query: R3QueryMetadata, constantPool: ConstantPool): o.Expression {\n  if (Array.isArray(query.predicate)) {\n    let predicate: o.Expression[] = [];\n    query.predicate.forEach((selector: string): void => {\n      // Each item in predicates array may contain strings with comma-separated refs\n      // (for ex. 'ref, ref1, ..., refN'), thus we extract individual refs and store them\n      // as separate array entities\n      const selectors = selector.split(',').map(token => o.literal(token.trim()));\n      predicate.push(...selectors);\n    });\n    return constantPool.getConstLiteral(o.literalArr(predicate), true);\n  } else {\n    return query.predicate;\n  }\n}\n\nexport function noop() {}\n\nexport class DefinitionMap {\n  values: {key: string, quoted: boolean, value: o.Expression}[] = [];\n\n  set(key: string, value: o.Expression|null): void {\n    if (value) {\n      this.values.push({key, value, quoted: false});\n    }\n  }\n\n  toLiteralMap(): o.LiteralMapExpr { return o.literalMap(this.values); }\n}\n\n/**\n * Extract a map of properties to values for a given element or template node, which can be used\n * by the directive matching machinery.\n *\n * @param elOrTpl the element or template in question\n * @return an object set up for directive matching. For attributes on the element/template, this\n * object maps a property name to its (static) value. For any bindings, this map simply maps the\n * property name to an empty string.\n */\nexport function getAttrsForDirectiveMatching(elOrTpl: t.Element | t.Template):\n    {[name: string]: string} {\n  const attributesMap: {[name: string]: string} = {};\n\n  elOrTpl.attributes.forEach(a => {\n    if (!isI18NAttribute(a.name)) {\n      attributesMap[a.name] = a.value;\n    }\n  });\n  elOrTpl.inputs.forEach(i => { attributesMap[i.name] = ''; });\n  elOrTpl.outputs.forEach(o => { attributesMap[o.name] = ''; });\n\n  return attributesMap;\n}\n"]}