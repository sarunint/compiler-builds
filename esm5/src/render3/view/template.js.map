{"version":3,"file":"template.js","sourceRoot":"","sources":["../../../../../../../packages/compiler/src/render3/view/template.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {flatten, sanitizeIdentifier} from '../../compile_metadata';\nimport {BindingForm, BuiltinFunctionCall, LocalResolver, convertActionBinding, convertPropertyBinding} from '../../compiler_util/expression_converter';\nimport {ConstantPool} from '../../constant_pool';\nimport * as core from '../../core';\nimport {AST, AstMemoryEfficientTransformer, BindingPipe, BindingType, FunctionCall, ImplicitReceiver, Interpolation, LiteralArray, LiteralMap, LiteralPrimitive, PropertyRead} from '../../expression_parser/ast';\nimport {Lexer} from '../../expression_parser/lexer';\nimport {Parser} from '../../expression_parser/parser';\nimport * as html from '../../ml_parser/ast';\nimport {HtmlParser} from '../../ml_parser/html_parser';\nimport {WhitespaceVisitor} from '../../ml_parser/html_whitespaces';\nimport {DEFAULT_INTERPOLATION_CONFIG} from '../../ml_parser/interpolation_config';\nimport {isNgContainer as checkIsNgContainer, splitNsName} from '../../ml_parser/tags';\nimport * as o from '../../output/output_ast';\nimport {ParseError, ParseSourceSpan} from '../../parse_util';\nimport {DomElementSchemaRegistry} from '../../schema/dom_element_schema_registry';\nimport {CssSelector, SelectorMatcher} from '../../selector';\nimport {BindingParser} from '../../template_parser/binding_parser';\nimport {error} from '../../util';\nimport * as t from '../r3_ast';\nimport {Identifiers as R3} from '../r3_identifiers';\nimport {htmlAstToRender3Ast} from '../r3_template_transform';\n\nimport {R3QueryMetadata} from './api';\nimport {I18N_ATTR, I18N_ATTR_PREFIX, I18nContext, assembleI18nBoundString} from './i18n';\nimport {parseStyle} from './styling';\nimport {CONTEXT_NAME, IMPLICIT_REFERENCE, NON_BINDABLE_ATTR, REFERENCE_PREFIX, RENDER_FLAGS, asLiteral, getAttrsForDirectiveMatching, invalid, trimTrailingNulls, unsupported} from './util';\n\nfunction mapBindingToInstruction(type: BindingType): o.ExternalReference|undefined {\n  switch (type) {\n    case BindingType.Property:\n      return R3.elementProperty;\n    case BindingType.Class:\n      return R3.elementClassProp;\n    case BindingType.Attribute:\n    case BindingType.Animation:\n      return R3.elementAttribute;\n    default:\n      return undefined;\n  }\n}\n\n//  if (rf & flags) { .. }\nexport function renderFlagCheckIfStmt(\n    flags: core.RenderFlags, statements: o.Statement[]): o.IfStmt {\n  return o.ifStmt(o.variable(RENDER_FLAGS).bitwiseAnd(o.literal(flags), null, false), statements);\n}\n\nexport class TemplateDefinitionBuilder implements t.Visitor<void>, LocalResolver {\n  private _dataIndex = 0;\n  private _bindingContext = 0;\n  private _prefixCode: o.Statement[] = [];\n  /**\n   * List of callbacks to generate creation mode instructions. We store them here as we process\n   * the template so bindings in listeners are resolved only once all nodes have been visited.\n   * This ensures all local refs and context variables are available for matching.\n   */\n  private _creationCodeFns: (() => o.Statement)[] = [];\n  /**\n   * List of callbacks to generate update mode instructions. We store them here as we process\n   * the template so bindings are resolved only once all nodes have been visited. This ensures\n   * all local refs and context variables are available for matching.\n   */\n  private _updateCodeFns: (() => o.Statement)[] = [];\n  /** Temporary variable declarations generated from visiting pipes, literals, etc. */\n  private _tempVariables: o.Statement[] = [];\n  /**\n   * List of callbacks to build nested templates. Nested templates must not be visited until\n   * after the parent template has finished visiting all of its nodes. This ensures that all\n   * local ref bindings in nested templates are able to find local ref values if the refs\n   * are defined after the template declaration.\n   */\n  private _nestedTemplateFns: (() => void)[] = [];\n  /**\n   * This scope contains local variables declared in the update mode block of the template.\n   * (e.g. refs and context vars in bindings)\n   */\n  private _bindingScope: BindingScope;\n  private _valueConverter: ValueConverter;\n  private _unsupported = unsupported;\n\n  // i18n context local to this template\n  private i18n: I18nContext|null = null;\n\n  // Number of slots to reserve for pureFunctions\n  private _pureFunctionSlots = 0;\n\n  // Number of binding slots\n  private _bindingSlots = 0;\n\n  private fileBasedI18nSuffix: string;\n\n  constructor(\n      private constantPool: ConstantPool, parentBindingScope: BindingScope, private level = 0,\n      private contextName: string|null, private i18nContext: I18nContext|null,\n      private templateIndex: number|null, private templateName: string|null,\n      private viewQueries: R3QueryMetadata[], private directiveMatcher: SelectorMatcher|null,\n      private directives: Set<o.Expression>, private pipeTypeByName: Map<string, o.Expression>,\n      private pipes: Set<o.Expression>, private _namespace: o.ExternalReference,\n      private relativeContextFilePath: string) {\n    // view queries can take up space in data and allocation happens earlier (in the \"viewQuery\"\n    // function)\n    this._dataIndex = viewQueries.length;\n\n    this._bindingScope = parentBindingScope.nestedScope(level);\n\n    // Turn the relative context file path into an identifier by replacing non-alphanumeric\n    // characters with underscores.\n    this.fileBasedI18nSuffix = relativeContextFilePath.replace(/[^A-Za-z0-9]/g, '_') + '_';\n\n    this._valueConverter = new ValueConverter(\n        constantPool, () => this.allocateDataSlot(),\n        (numSlots: number) => this.allocatePureFunctionSlots(numSlots),\n        (name, localName, slot, value: o.ReadVarExpr) => {\n          const pipeType = pipeTypeByName.get(name);\n          if (pipeType) {\n            this.pipes.add(pipeType);\n          }\n          this._bindingScope.set(this.level, localName, value);\n          this.creationInstruction(null, R3.pipe, [o.literal(slot), o.literal(name)]);\n        });\n  }\n\n  registerContextVariables(variable: t.Variable) {\n    const scopedName = this._bindingScope.freshReferenceName();\n    const retrievalLevel = this.level;\n    const lhs = o.variable(variable.name + scopedName);\n    this._bindingScope.set(\n        retrievalLevel, variable.name, lhs, DeclarationPriority.CONTEXT,\n        (scope: BindingScope, relativeLevel: number) => {\n          let rhs: o.Expression;\n          if (scope.bindingLevel === retrievalLevel) {\n            // e.g. ctx\n            rhs = o.variable(CONTEXT_NAME);\n          } else {\n            const sharedCtxVar = scope.getSharedContextName(retrievalLevel);\n            // e.g. ctx_r0   OR  x(2);\n            rhs = sharedCtxVar ? sharedCtxVar : generateNextContextExpr(relativeLevel);\n          }\n          // e.g. const $item$ = x(2).$implicit;\n          return [lhs.set(rhs.prop(variable.value || IMPLICIT_REFERENCE)).toConstDecl()];\n        });\n  }\n\n  buildTemplateFunction(\n      nodes: t.Node[], variables: t.Variable[], hasNgContent: boolean = false,\n      ngContentSelectors: string[] = []): o.FunctionExpr {\n    if (this._namespace !== R3.namespaceHTML) {\n      this.creationInstruction(null, this._namespace);\n    }\n\n    // Create variable bindings\n    variables.forEach(v => this.registerContextVariables(v));\n\n    // Output a `ProjectionDef` instruction when some `<ng-content>` are present\n    if (hasNgContent) {\n      const parameters: o.Expression[] = [];\n\n      // Only selectors with a non-default value are generated\n      if (ngContentSelectors.length > 1) {\n        const r3Selectors = ngContentSelectors.map(s => core.parseSelectorToR3Selector(s));\n        // `projectionDef` needs both the parsed and raw value of the selectors\n        const parsed = this.constantPool.getConstLiteral(asLiteral(r3Selectors), true);\n        const unParsed = this.constantPool.getConstLiteral(asLiteral(ngContentSelectors), true);\n        parameters.push(parsed, unParsed);\n      }\n\n      this.creationInstruction(null, R3.projectionDef, parameters);\n    }\n\n    if (this.i18nContext) {\n      this.i18nStart();\n    }\n\n    // This is the initial pass through the nodes of this template. In this pass, we\n    // queue all creation mode and update mode instructions for generation in the second\n    // pass. It's necessary to separate the passes to ensure local refs are defined before\n    // resolving bindings. We also count bindings in this pass as we walk bound expressions.\n    t.visitAll(this, nodes);\n\n    // Add total binding count to pure function count so pure function instructions are\n    // generated with the correct slot offset when update instructions are processed.\n    this._pureFunctionSlots += this._bindingSlots;\n\n    // Pipes are walked in the first pass (to enqueue `pipe()` creation instructions and\n    // `pipeBind` update instructions), so we have to update the slot offsets manually\n    // to account for bindings.\n    this._valueConverter.updatePipeSlotOffsets(this._bindingSlots);\n\n    // Nested templates must be processed before creation instructions so template()\n    // instructions can be generated with the correct internal const count.\n    this._nestedTemplateFns.forEach(buildTemplateFn => buildTemplateFn());\n\n    if (this.i18nContext) {\n      this.i18nEnd();\n    }\n\n    // Generate all the creation mode instructions (e.g. resolve bindings in listeners)\n    const creationStatements = this._creationCodeFns.map((fn: () => o.Statement) => fn());\n\n    // Generate all the update mode instructions (e.g. resolve property or text bindings)\n    const updateStatements = this._updateCodeFns.map((fn: () => o.Statement) => fn());\n\n    //  Variable declaration must occur after binding resolution so we can generate context\n    //  instructions that build on each other. e.g. const b = x().$implicit(); const b = x();\n    const creationVariables = this._bindingScope.viewSnapshotStatements();\n    const updateVariables = this._bindingScope.variableDeclarations().concat(this._tempVariables);\n\n    const creationBlock = creationStatements.length > 0 ?\n        [renderFlagCheckIfStmt(\n            core.RenderFlags.Create, creationVariables.concat(creationStatements))] :\n        [];\n\n    const updateBlock = updateStatements.length > 0 ?\n        [renderFlagCheckIfStmt(core.RenderFlags.Update, updateVariables.concat(updateStatements))] :\n        [];\n\n    return o.fn(\n        // i.e. (rf: RenderFlags, ctx: any)\n        [new o.FnParam(RENDER_FLAGS, o.NUMBER_TYPE), new o.FnParam(CONTEXT_NAME, null)],\n        [\n          // Temporary variable declarations for query refresh (i.e. let _t: any;)\n          ...this._prefixCode,\n          // Creating mode (i.e. if (rf & RenderFlags.Create) { ... })\n          ...creationBlock,\n          // Binding and refresh mode (i.e. if (rf & RenderFlags.Update) {...})\n          ...updateBlock,\n        ],\n        o.INFERRED_TYPE, null, this.templateName);\n  }\n\n  // LocalResolver\n  getLocal(name: string): o.Expression|null { return this._bindingScope.get(name); }\n\n  i18nTranslate(label: string, meta: string = ''): o.Expression {\n    return this.constantPool.getTranslation(label, meta, this.fileBasedI18nSuffix);\n  }\n\n  i18nAppendTranslationMeta(meta: string = '') { this.constantPool.appendTranslationMeta(meta); }\n\n  i18nAllocateRef(): o.ReadVarExpr {\n    return this.constantPool.getDeferredTranslationConst(this.fileBasedI18nSuffix);\n  }\n\n  i18nUpdateRef(context: I18nContext): void {\n    if (context.isRoot() && context.isResolved()) {\n      this.constantPool.setDeferredTranslationConst(context.getRef(), context.getContent());\n    }\n  }\n\n  i18nStart(span: ParseSourceSpan|null = null, meta?: string): void {\n    const index = this.allocateDataSlot();\n    if (this.i18nContext) {\n      this.i18n = this.i18nContext.forkChildContext(index, this.templateIndex !);\n    } else {\n      this.i18nAppendTranslationMeta(meta);\n      const ref = this.i18nAllocateRef();\n      this.i18n = new I18nContext(index, this.templateIndex, ref);\n    }\n\n    // generate i18nStart instruction\n    const params: o.Expression[] = [o.literal(index), this.i18n.getRef()];\n    if (this.i18n.getId() > 0) {\n      // do not push 3rd argument (sub-block id)\n      // into i18nStart call for top level i18n context\n      params.push(o.literal(this.i18n.getId()));\n    }\n    this.creationInstruction(span, R3.i18nStart, params);\n  }\n\n  i18nEnd(span: ParseSourceSpan|null = null): void {\n    if (this.i18nContext) {\n      this.i18nContext.reconcileChildContext(this.i18n !);\n      this.i18nUpdateRef(this.i18nContext);\n    } else {\n      this.i18nUpdateRef(this.i18n !);\n    }\n\n    // setup accumulated bindings\n    const bindings = this.i18n !.getBindings();\n    if (bindings.size) {\n      bindings.forEach(binding => { this.updateInstruction(span, R3.i18nExp, [binding]); });\n      const index: o.Expression = o.literal(this.i18n !.getIndex());\n      this.updateInstruction(span, R3.i18nApply, [index]);\n    }\n\n    this.creationInstruction(span, R3.i18nEnd);\n    this.i18n = null;  // reset local i18n context\n  }\n\n  visitContent(ngContent: t.Content) {\n    const slot = this.allocateDataSlot();\n    const selectorIndex = ngContent.selectorIndex;\n    const parameters: o.Expression[] = [o.literal(slot)];\n\n    const attributeAsList: string[] = [];\n\n    ngContent.attributes.forEach((attribute) => {\n      const name = attribute.name;\n      if (name !== 'select') {\n        attributeAsList.push(name, attribute.value);\n      }\n    });\n\n    if (attributeAsList.length > 0) {\n      parameters.push(o.literal(selectorIndex), asLiteral(attributeAsList));\n    } else if (selectorIndex !== 0) {\n      parameters.push(o.literal(selectorIndex));\n    }\n\n    this.creationInstruction(ngContent.sourceSpan, R3.projection, parameters);\n  }\n\n\n  getNamespaceInstruction(namespaceKey: string|null) {\n    switch (namespaceKey) {\n      case 'math':\n        return R3.namespaceMathML;\n      case 'svg':\n        return R3.namespaceSVG;\n      default:\n        return R3.namespaceHTML;\n    }\n  }\n\n  addNamespaceInstruction(nsInstruction: o.ExternalReference, element: t.Element) {\n    this._namespace = nsInstruction;\n    this.creationInstruction(element.sourceSpan, nsInstruction);\n  }\n\n  visitElement(element: t.Element) {\n    const elementIndex = this.allocateDataSlot();\n\n    let isNonBindableMode: boolean = false;\n    let isI18nRootElement: boolean = false;\n\n    const outputAttrs: {[name: string]: string} = {};\n    const attrI18nMetas: {[name: string]: string} = {};\n    let i18nMeta: string = '';\n\n    const [namespaceKey, elementName] = splitNsName(element.name);\n    const isNgContainer = checkIsNgContainer(element.name);\n\n    // Handle i18n and ngNonBindable attributes\n    for (const attr of element.attributes) {\n      const name = attr.name;\n      const value = attr.value;\n      if (name === NON_BINDABLE_ATTR) {\n        isNonBindableMode = true;\n      } else if (name === I18N_ATTR) {\n        if (this.i18n) {\n          throw new Error(\n              `Could not mark an element as translatable inside of a translatable section`);\n        }\n        isI18nRootElement = true;\n        i18nMeta = value;\n      } else if (name.startsWith(I18N_ATTR_PREFIX)) {\n        attrI18nMetas[name.slice(I18N_ATTR_PREFIX.length)] = value;\n      } else {\n        outputAttrs[name] = value;\n      }\n    }\n\n    // Match directives on non i18n attributes\n    this.matchDirectives(element.name, element);\n\n    // Regular element or ng-container creation mode\n    const parameters: o.Expression[] = [o.literal(elementIndex)];\n    if (!isNgContainer) {\n      parameters.push(o.literal(elementName));\n    }\n\n    // Add the attributes\n    const attributes: o.Expression[] = [];\n    const initialStyleDeclarations: o.Expression[] = [];\n    const initialClassDeclarations: o.Expression[] = [];\n\n    const styleInputs: t.BoundAttribute[] = [];\n    const classInputs: t.BoundAttribute[] = [];\n    const allOtherInputs: t.BoundAttribute[] = [];\n\n    const i18nAttrs: Array<{name: string, value: string | AST}> = [];\n\n    element.inputs.forEach((input: t.BoundAttribute) => {\n      switch (input.type) {\n        // [attr.style] or [attr.class] should not be treated as styling-based\n        // bindings since they are intended to be written directly to the attr\n        // and therefore will skip all style/class resolution that is present\n        // with style=\"\", [style]=\"\" and [style.prop]=\"\", class=\"\",\n        // [class.prop]=\"\". [class]=\"\" assignments\n        case BindingType.Property:\n          if (input.name == 'style') {\n            // this should always go first in the compilation (for [style])\n            styleInputs.splice(0, 0, input);\n          } else if (isClassBinding(input)) {\n            // this should always go first in the compilation (for [class])\n            classInputs.splice(0, 0, input);\n          } else if (attrI18nMetas.hasOwnProperty(input.name)) {\n            i18nAttrs.push({name: input.name, value: input.value});\n          } else {\n            allOtherInputs.push(input);\n          }\n          break;\n        case BindingType.Style:\n          styleInputs.push(input);\n          break;\n        case BindingType.Class:\n          classInputs.push(input);\n          break;\n        default:\n          allOtherInputs.push(input);\n          break;\n      }\n    });\n\n    let currStyleIndex = 0;\n    let currClassIndex = 0;\n    let staticStylesMap: {[key: string]: any}|null = null;\n    let staticClassesMap: {[key: string]: boolean}|null = null;\n    const stylesIndexMap: {[key: string]: number} = {};\n    const classesIndexMap: {[key: string]: number} = {};\n    Object.getOwnPropertyNames(outputAttrs).forEach(name => {\n      const value = outputAttrs[name];\n      if (name == 'style') {\n        staticStylesMap = parseStyle(value);\n        Object.keys(staticStylesMap).forEach(prop => { stylesIndexMap[prop] = currStyleIndex++; });\n      } else if (name == 'class') {\n        staticClassesMap = {};\n        value.split(/\\s+/g).forEach(className => {\n          classesIndexMap[className] = currClassIndex++;\n          staticClassesMap ![className] = true;\n        });\n      } else {\n        if (attrI18nMetas.hasOwnProperty(name)) {\n          i18nAttrs.push({name, value});\n        } else {\n          attributes.push(o.literal(name), o.literal(value));\n        }\n      }\n    });\n\n    let hasMapBasedStyling = false;\n    for (let i = 0; i < styleInputs.length; i++) {\n      const input = styleInputs[i];\n      const isMapBasedStyleBinding = i === 0 && input.name === 'style';\n      if (isMapBasedStyleBinding) {\n        hasMapBasedStyling = true;\n      } else if (!stylesIndexMap.hasOwnProperty(input.name)) {\n        stylesIndexMap[input.name] = currStyleIndex++;\n      }\n    }\n\n    for (let i = 0; i < classInputs.length; i++) {\n      const input = classInputs[i];\n      const isMapBasedClassBinding = i === 0 && isClassBinding(input);\n      if (!isMapBasedClassBinding && !stylesIndexMap.hasOwnProperty(input.name)) {\n        classesIndexMap[input.name] = currClassIndex++;\n      }\n    }\n\n    // in the event that a [style] binding is used then sanitization will\n    // always be imported because it is not possible to know ahead of time\n    // whether style bindings will use or not use any sanitizable properties\n    // that isStyleSanitizable() will detect\n    let useDefaultStyleSanitizer = hasMapBasedStyling;\n\n    // this will build the instructions so that they fall into the following syntax\n    // => [prop1, prop2, prop3, 0, prop1, value1, prop2, value2]\n    Object.keys(stylesIndexMap).forEach(prop => {\n      useDefaultStyleSanitizer = useDefaultStyleSanitizer || isStyleSanitizable(prop);\n      initialStyleDeclarations.push(o.literal(prop));\n    });\n\n    if (staticStylesMap) {\n      initialStyleDeclarations.push(o.literal(core.InitialStylingFlags.VALUES_MODE));\n\n      Object.keys(staticStylesMap).forEach(prop => {\n        initialStyleDeclarations.push(o.literal(prop));\n        const value = staticStylesMap ![prop];\n        initialStyleDeclarations.push(o.literal(value));\n      });\n    }\n\n    Object.keys(classesIndexMap).forEach(prop => {\n      initialClassDeclarations.push(o.literal(prop));\n    });\n\n    if (staticClassesMap) {\n      initialClassDeclarations.push(o.literal(core.InitialStylingFlags.VALUES_MODE));\n\n      Object.keys(staticClassesMap).forEach(className => {\n        initialClassDeclarations.push(o.literal(className));\n        initialClassDeclarations.push(o.literal(true));\n      });\n    }\n\n    const hasStylingInstructions = initialStyleDeclarations.length || styleInputs.length ||\n        initialClassDeclarations.length || classInputs.length;\n\n    // add attributes for directive matching purposes\n    attributes.push(...this.prepareSyntheticAndSelectOnlyAttrs(allOtherInputs, element.outputs));\n    parameters.push(this.toAttrsParam(attributes));\n\n    // local refs (ex.: <div #foo #bar=\"baz\">)\n    parameters.push(this.prepareRefsParameter(element.references));\n\n    const wasInNamespace = this._namespace;\n    const currentNamespace = this.getNamespaceInstruction(namespaceKey);\n\n    // If the namespace is changing now, include an instruction to change it\n    // during element creation.\n    if (currentNamespace !== wasInNamespace) {\n      this.addNamespaceInstruction(currentNamespace, element);\n    }\n\n    const implicit = o.variable(CONTEXT_NAME);\n\n    if (this.i18n) {\n      this.i18n.appendElement(elementIndex);\n    }\n\n    const hasChildren = () => {\n      if (!isI18nRootElement && this.i18n) {\n        // we do not append text node instructions inside i18n section, so we\n        // exclude them while calculating whether current element has children\n        return element.children.find(\n            child => !(child instanceof t.Text || child instanceof t.BoundText));\n      }\n      return element.children.length > 0;\n    };\n\n    const createSelfClosingInstruction = !hasStylingInstructions && !isNgContainer &&\n        element.outputs.length === 0 && i18nAttrs.length === 0 && !hasChildren();\n\n    if (createSelfClosingInstruction) {\n      this.creationInstruction(element.sourceSpan, R3.element, trimTrailingNulls(parameters));\n    } else {\n      this.creationInstruction(\n          element.sourceSpan, isNgContainer ? R3.elementContainerStart : R3.elementStart,\n          trimTrailingNulls(parameters));\n\n      if (isNonBindableMode) {\n        this.creationInstruction(element.sourceSpan, R3.disableBindings);\n      }\n\n      if (isI18nRootElement) {\n        this.i18nStart(element.sourceSpan, i18nMeta);\n      }\n\n      // process i18n element attributes\n      if (i18nAttrs.length) {\n        let hasBindings: boolean = false;\n        const i18nAttrArgs: o.Expression[] = [];\n        i18nAttrs.forEach(({name, value}) => {\n          const meta = attrI18nMetas[name];\n          if (typeof value === 'string') {\n            // in case of static string value, 3rd argument is 0 declares\n            // that there are no expressions defined in this translation\n            i18nAttrArgs.push(o.literal(name), this.i18nTranslate(value, meta), o.literal(0));\n          } else {\n            const converted = value.visit(this._valueConverter);\n            if (converted instanceof Interpolation) {\n              const {strings, expressions} = converted;\n              const label = assembleI18nBoundString(strings);\n              i18nAttrArgs.push(\n                  o.literal(name), this.i18nTranslate(label, meta), o.literal(expressions.length));\n              expressions.forEach(expression => {\n                hasBindings = true;\n                const binding = this.convertExpressionBinding(implicit, expression);\n                this.updateInstruction(element.sourceSpan, R3.i18nExp, [binding]);\n              });\n            }\n          }\n        });\n        if (i18nAttrArgs.length) {\n          const index: o.Expression = o.literal(this.allocateDataSlot());\n          const args = this.constantPool.getConstLiteral(o.literalArr(i18nAttrArgs), true);\n          this.creationInstruction(element.sourceSpan, R3.i18nAttribute, [index, args]);\n          if (hasBindings) {\n            this.updateInstruction(element.sourceSpan, R3.i18nApply, [index]);\n          }\n        }\n      }\n\n      // initial styling for static style=\"...\" attributes\n      if (hasStylingInstructions) {\n        const paramsList: (o.Expression)[] = [];\n\n        if (initialClassDeclarations.length) {\n          // the template compiler handles initial class styling (e.g. class=\"foo\") values\n          // in a special command called `elementClass` so that the initial class\n          // can be processed during runtime. These initial class values are bound to\n          // a constant because the inital class values do not change (since they're static).\n          paramsList.push(\n              this.constantPool.getConstLiteral(o.literalArr(initialClassDeclarations), true));\n        } else if (initialStyleDeclarations.length || useDefaultStyleSanitizer) {\n          // no point in having an extra `null` value unless there are follow-up params\n          paramsList.push(o.NULL_EXPR);\n        }\n\n        if (initialStyleDeclarations.length) {\n          // the template compiler handles initial style (e.g. style=\"foo\") values\n          // in a special command called `elementStyle` so that the initial styles\n          // can be processed during runtime. These initial styles values are bound to\n          // a constant because the inital style values do not change (since they're static).\n          paramsList.push(\n              this.constantPool.getConstLiteral(o.literalArr(initialStyleDeclarations), true));\n        } else if (useDefaultStyleSanitizer) {\n          // no point in having an extra `null` value unless there are follow-up params\n          paramsList.push(o.NULL_EXPR);\n        }\n\n        if (useDefaultStyleSanitizer) {\n          paramsList.push(o.importExpr(R3.defaultStyleSanitizer));\n        }\n\n        this.creationInstruction(null, R3.elementStyling, paramsList);\n      }\n\n      // Generate Listeners (outputs)\n      element.outputs.forEach((outputAst: t.BoundEvent) => {\n        this.creationInstruction(\n            outputAst.sourceSpan, R3.listener,\n            this.prepareListenerParameter(element.name, outputAst));\n      });\n    }\n\n    if ((styleInputs.length || classInputs.length) && hasStylingInstructions) {\n      const indexLiteral = o.literal(elementIndex);\n\n      const firstStyle = styleInputs[0];\n      const mapBasedStyleInput = firstStyle && firstStyle.name == 'style' ? firstStyle : null;\n\n      const firstClass = classInputs[0];\n      const mapBasedClassInput = firstClass && isClassBinding(firstClass) ? firstClass : null;\n\n      const stylingInput = mapBasedStyleInput || mapBasedClassInput;\n      if (stylingInput) {\n        // these values must be outside of the update block so that they can\n        // be evaluted (the AST visit call) during creation time so that any\n        // pipes can be picked up in time before the template is built\n        const mapBasedClassValue =\n            mapBasedClassInput ? mapBasedClassInput.value.visit(this._valueConverter) : null;\n        const mapBasedStyleValue =\n            mapBasedStyleInput ? mapBasedStyleInput.value.visit(this._valueConverter) : null;\n        this.updateInstruction(stylingInput.sourceSpan, R3.elementStylingMap, () => {\n          const params: o.Expression[] = [indexLiteral];\n\n          if (mapBasedClassValue) {\n            params.push(this.convertPropertyBinding(implicit, mapBasedClassValue, true));\n          } else if (mapBasedStyleInput) {\n            params.push(o.NULL_EXPR);\n          }\n\n          if (mapBasedStyleValue) {\n            params.push(this.convertPropertyBinding(implicit, mapBasedStyleValue, true));\n          }\n\n          return params;\n        });\n      }\n\n      let lastInputCommand: t.BoundAttribute|null = null;\n      if (styleInputs.length) {\n        let i = mapBasedStyleInput ? 1 : 0;\n        for (i; i < styleInputs.length; i++) {\n          const input = styleInputs[i];\n          const key = input.name;\n          const styleIndex: number = stylesIndexMap[key] !;\n          const value = input.value.visit(this._valueConverter);\n          this.updateInstruction(input.sourceSpan, R3.elementStyleProp, () => {\n            const params: o.Expression[] = [\n              indexLiteral, o.literal(styleIndex),\n              this.convertPropertyBinding(implicit, value, true)\n            ];\n\n            if (input.unit != null) {\n              params.push(o.literal(input.unit));\n            }\n\n            return params;\n          });\n        }\n\n        lastInputCommand = styleInputs[styleInputs.length - 1];\n      }\n\n      if (classInputs.length) {\n        let i = mapBasedClassInput ? 1 : 0;\n        for (i; i < classInputs.length; i++) {\n          const input = classInputs[i];\n          const params: any[] = [];\n          const sanitizationRef = resolveSanitizationFn(input, input.securityContext);\n          if (sanitizationRef) params.push(sanitizationRef);\n\n          const key = input.name;\n          const classIndex: number = classesIndexMap[key] !;\n          const value = input.value.visit(this._valueConverter);\n          this.updateInstruction(input.sourceSpan, R3.elementClassProp, () => {\n            const valueLiteral = this.convertPropertyBinding(implicit, value, true);\n            return [indexLiteral, o.literal(classIndex), valueLiteral];\n          });\n        }\n\n        lastInputCommand = classInputs[classInputs.length - 1];\n      }\n\n      this.updateInstruction(lastInputCommand !.sourceSpan, R3.elementStylingApply, [indexLiteral]);\n    }\n\n    // Generate element input bindings\n    allOtherInputs.forEach((input: t.BoundAttribute) => {\n      const instruction = mapBindingToInstruction(input.type);\n      if (input.type === BindingType.Animation) {\n        const value = input.value.visit(this._valueConverter);\n        // setAttribute without a value doesn't make any sense\n        if (value.name || value.value) {\n          const name = prepareSyntheticAttributeName(input.name);\n          this.updateInstruction(input.sourceSpan, R3.elementAttribute, () => {\n            return [\n              o.literal(elementIndex), o.literal(name), this.convertPropertyBinding(implicit, value)\n            ];\n          });\n        }\n      } else if (instruction) {\n        const params: any[] = [];\n        const sanitizationRef = resolveSanitizationFn(input, input.securityContext);\n        if (sanitizationRef) params.push(sanitizationRef);\n\n        // TODO(chuckj): runtime: security context\n        const value = input.value.visit(this._valueConverter);\n        this.allocateBindingSlots(value);\n\n        this.updateInstruction(input.sourceSpan, instruction, () => {\n          return [\n            o.literal(elementIndex), o.literal(input.name),\n            this.convertPropertyBinding(implicit, value), ...params\n          ];\n        });\n      } else {\n        this._unsupported(`binding type ${input.type}`);\n      }\n    });\n\n    // Traverse element child nodes\n    t.visitAll(this, element.children);\n\n    if (!isI18nRootElement && this.i18n) {\n      this.i18n.appendElement(elementIndex, true);\n    }\n\n    if (!createSelfClosingInstruction) {\n      // Finish element construction mode.\n      const span = element.endSourceSpan || element.sourceSpan;\n      if (isI18nRootElement) {\n        this.i18nEnd(span);\n      }\n      if (isNonBindableMode) {\n        this.creationInstruction(span, R3.enableBindings);\n      }\n      this.creationInstruction(span, isNgContainer ? R3.elementContainerEnd : R3.elementEnd);\n    }\n  }\n\n  visitTemplate(template: t.Template) {\n    const templateIndex = this.allocateDataSlot();\n\n    if (this.i18n) {\n      this.i18n.appendTemplate(templateIndex);\n    }\n\n    let elName = '';\n    if (template.children.length === 1 && template.children[0] instanceof t.Element) {\n      // When the template as a single child, derive the context name from the tag\n      elName = sanitizeIdentifier((template.children[0] as t.Element).name);\n    }\n\n    const contextName = elName ? `${this.contextName}_${elName}` : '';\n\n    const templateName =\n        contextName ? `${contextName}_Template_${templateIndex}` : `Template_${templateIndex}`;\n\n    const parameters: o.Expression[] = [\n      o.literal(templateIndex),\n      o.variable(templateName),\n      o.TYPED_NULL_EXPR,\n    ];\n\n    // find directives matching on a given <ng-template> node\n    this.matchDirectives('ng-template', template);\n\n    // prepare attributes parameter (including attributes used for directive matching)\n    const attrsExprs: o.Expression[] = [];\n    template.attributes.forEach(\n        (a: t.TextAttribute) => { attrsExprs.push(asLiteral(a.name), asLiteral(a.value)); });\n    attrsExprs.push(...this.prepareSyntheticAndSelectOnlyAttrs(template.inputs, template.outputs));\n    parameters.push(this.toAttrsParam(attrsExprs));\n\n    // local refs (ex.: <ng-template #foo>)\n    if (template.references && template.references.length) {\n      parameters.push(this.prepareRefsParameter(template.references));\n      parameters.push(o.importExpr(R3.templateRefExtractor));\n    }\n\n    // handle property bindings e.g. p(1, 'forOf', bind(ctx.items));\n    const context = o.variable(CONTEXT_NAME);\n    template.inputs.forEach(input => {\n      const value = input.value.visit(this._valueConverter);\n      this.allocateBindingSlots(value);\n      this.updateInstruction(template.sourceSpan, R3.elementProperty, () => {\n        return [\n          o.literal(templateIndex), o.literal(input.name),\n          this.convertPropertyBinding(context, value)\n        ];\n      });\n    });\n\n    // Create the template function\n    const templateVisitor = new TemplateDefinitionBuilder(\n        this.constantPool, this._bindingScope, this.level + 1, contextName, this.i18n,\n        templateIndex, templateName, [], this.directiveMatcher, this.directives,\n        this.pipeTypeByName, this.pipes, this._namespace, this.fileBasedI18nSuffix);\n\n    // Nested templates must not be visited until after their parent templates have completed\n    // processing, so they are queued here until after the initial pass. Otherwise, we wouldn't\n    // be able to support bindings in nested templates to local refs that occur after the\n    // template definition. e.g. <div *ngIf=\"showing\"> {{ foo }} </div>  <div #foo></div>\n    this._nestedTemplateFns.push(() => {\n      const templateFunctionExpr =\n          templateVisitor.buildTemplateFunction(template.children, template.variables);\n      this.constantPool.statements.push(templateFunctionExpr.toDeclStmt(templateName, null));\n    });\n\n    // e.g. template(1, MyComp_Template_1)\n    this.creationInstruction(template.sourceSpan, R3.templateCreate, () => {\n      parameters.splice(\n          2, 0, o.literal(templateVisitor.getConstCount()),\n          o.literal(templateVisitor.getVarCount()));\n      return trimTrailingNulls(parameters);\n    });\n\n    // Generate listeners for directive output\n    template.outputs.forEach((outputAst: t.BoundEvent) => {\n      this.creationInstruction(\n          outputAst.sourceSpan, R3.listener,\n          this.prepareListenerParameter('ng_template', outputAst));\n    });\n  }\n\n  // These should be handled in the template or element directly.\n  readonly visitReference = invalid;\n  readonly visitVariable = invalid;\n  readonly visitTextAttribute = invalid;\n  readonly visitBoundAttribute = invalid;\n  readonly visitBoundEvent = invalid;\n\n  visitBoundText(text: t.BoundText) {\n    if (this.i18n) {\n      const value = text.value.visit(this._valueConverter);\n      if (value instanceof Interpolation) {\n        const {strings, expressions} = value;\n        const label =\n            assembleI18nBoundString(strings, this.i18n.getBindings().size, this.i18n.getId());\n        const implicit = o.variable(CONTEXT_NAME);\n        expressions.forEach(expression => {\n          const binding = this.convertExpressionBinding(implicit, expression);\n          this.i18n !.appendBinding(binding);\n        });\n        this.i18n.appendText(label);\n      }\n      return;\n    }\n\n    const nodeIndex = this.allocateDataSlot();\n\n    this.creationInstruction(text.sourceSpan, R3.text, [o.literal(nodeIndex)]);\n\n    const value = text.value.visit(this._valueConverter);\n    this.allocateBindingSlots(value);\n    this.updateInstruction(\n        text.sourceSpan, R3.textBinding,\n        () => [o.literal(nodeIndex), this.convertPropertyBinding(o.variable(CONTEXT_NAME), value)]);\n  }\n\n  visitText(text: t.Text) {\n    if (this.i18n) {\n      this.i18n.appendText(text.value);\n      return;\n    }\n    this.creationInstruction(\n        text.sourceSpan, R3.text, [o.literal(this.allocateDataSlot()), o.literal(text.value)]);\n  }\n\n  private allocateDataSlot() { return this._dataIndex++; }\n\n  getConstCount() { return this._dataIndex; }\n\n  getVarCount() { return this._pureFunctionSlots; }\n\n  private bindingContext() { return `${this._bindingContext++}`; }\n\n  // Bindings must only be resolved after all local refs have been visited, so all\n  // instructions are queued in callbacks that execute once the initial pass has completed.\n  // Otherwise, we wouldn't be able to support local refs that are defined after their\n  // bindings. e.g. {{ foo }} <div #foo></div>\n  private instructionFn(\n      fns: (() => o.Statement)[], span: ParseSourceSpan|null, reference: o.ExternalReference,\n      paramsOrFn: o.Expression[]|(() => o.Expression[])): void {\n    fns.push(() => {\n      const params = Array.isArray(paramsOrFn) ? paramsOrFn : paramsOrFn();\n      return instruction(span, reference, params).toStmt();\n    });\n  }\n\n  private creationInstruction(\n      span: ParseSourceSpan|null, reference: o.ExternalReference,\n      paramsOrFn?: o.Expression[]|(() => o.Expression[])) {\n    this.instructionFn(this._creationCodeFns, span, reference, paramsOrFn || []);\n  }\n\n  private updateInstruction(\n      span: ParseSourceSpan|null, reference: o.ExternalReference,\n      paramsOrFn?: o.Expression[]|(() => o.Expression[])) {\n    this.instructionFn(this._updateCodeFns, span, reference, paramsOrFn || []);\n  }\n\n  private allocatePureFunctionSlots(numSlots: number): number {\n    const originalSlots = this._pureFunctionSlots;\n    this._pureFunctionSlots += numSlots;\n    return originalSlots;\n  }\n\n  private allocateBindingSlots(value: AST) {\n    this._bindingSlots += value instanceof Interpolation ? value.expressions.length : 1;\n  }\n\n  private convertExpressionBinding(implicit: o.Expression, value: AST): o.Expression {\n    const convertedPropertyBinding =\n        convertPropertyBinding(this, implicit, value, this.bindingContext(), BindingForm.TrySimple);\n    const valExpr = convertedPropertyBinding.currValExpr;\n    return o.importExpr(R3.bind).callFn([valExpr]);\n  }\n\n  private convertPropertyBinding(implicit: o.Expression, value: AST, skipBindFn?: boolean):\n      o.Expression {\n    const interpolationFn =\n        value instanceof Interpolation ? interpolate : () => error('Unexpected interpolation');\n\n    const convertedPropertyBinding = convertPropertyBinding(\n        this, implicit, value, this.bindingContext(), BindingForm.TrySimple, interpolationFn);\n    this._tempVariables.push(...convertedPropertyBinding.stmts);\n\n    const valExpr = convertedPropertyBinding.currValExpr;\n    return value instanceof Interpolation || skipBindFn ? valExpr :\n                                                          o.importExpr(R3.bind).callFn([valExpr]);\n  }\n\n  private matchDirectives(tagName: string, elOrTpl: t.Element|t.Template) {\n    if (this.directiveMatcher) {\n      const selector = createCssSelector(tagName, getAttrsForDirectiveMatching(elOrTpl));\n      this.directiveMatcher.match(\n          selector, (cssSelector, staticType) => { this.directives.add(staticType); });\n    }\n  }\n\n  private prepareSyntheticAndSelectOnlyAttrs(inputs: t.BoundAttribute[], outputs: t.BoundEvent[]):\n      o.Expression[] {\n    const attrExprs: o.Expression[] = [];\n    const nonSyntheticInputs: t.BoundAttribute[] = [];\n\n    if (inputs.length) {\n      const EMPTY_STRING_EXPR = asLiteral('');\n      inputs.forEach(input => {\n        if (input.type === BindingType.Animation) {\n          // @attributes are for Renderer2 animation @triggers, but this feature\n          // may be supported differently in future versions of angular. However,\n          // @triggers should always just be treated as regular attributes (it's up\n          // to the renderer to detect and use them in a special way).\n          attrExprs.push(asLiteral(prepareSyntheticAttributeName(input.name)), EMPTY_STRING_EXPR);\n        } else {\n          nonSyntheticInputs.push(input);\n        }\n      });\n    }\n\n    if (nonSyntheticInputs.length || outputs.length) {\n      attrExprs.push(o.literal(core.AttributeMarker.SelectOnly));\n      nonSyntheticInputs.forEach((i: t.BoundAttribute) => attrExprs.push(asLiteral(i.name)));\n      outputs.forEach((o: t.BoundEvent) => attrExprs.push(asLiteral(o.name)));\n    }\n\n    return attrExprs;\n  }\n\n  private toAttrsParam(attrsExprs: o.Expression[]): o.Expression {\n    return attrsExprs.length > 0 ?\n        this.constantPool.getConstLiteral(o.literalArr(attrsExprs), true) :\n        o.TYPED_NULL_EXPR;\n  }\n\n  private prepareRefsParameter(references: t.Reference[]): o.Expression {\n    if (!references || references.length === 0) {\n      return o.TYPED_NULL_EXPR;\n    }\n\n    const refsParam = flatten(references.map(reference => {\n      const slot = this.allocateDataSlot();\n      // Generate the update temporary.\n      const variableName = this._bindingScope.freshReferenceName();\n      const retrievalLevel = this.level;\n      const lhs = o.variable(variableName);\n      this._bindingScope.set(\n          retrievalLevel, reference.name, lhs, DeclarationPriority.DEFAULT,\n          (scope: BindingScope, relativeLevel: number) => {\n            // e.g. x(2);\n            const nextContextStmt =\n                relativeLevel > 0 ? [generateNextContextExpr(relativeLevel).toStmt()] : [];\n\n            // e.g. const $foo$ = r(1);\n            const refExpr = lhs.set(o.importExpr(R3.reference).callFn([o.literal(slot)]));\n            return nextContextStmt.concat(refExpr.toConstDecl());\n          });\n      return [reference.name, reference.value];\n    }));\n\n    return this.constantPool.getConstLiteral(asLiteral(refsParam), true);\n  }\n\n  private prepareListenerParameter(tagName: string, outputAst: t.BoundEvent): () => o.Expression[] {\n    const evNameSanitized = sanitizeIdentifier(outputAst.name);\n    const tagNameSanitized = sanitizeIdentifier(tagName);\n    const functionName = `${this.templateName}_${tagNameSanitized}_${evNameSanitized}_listener`;\n\n    return () => {\n\n      const listenerScope = this._bindingScope.nestedScope(this._bindingScope.bindingLevel);\n\n      const bindingExpr = convertActionBinding(\n          listenerScope, o.variable(CONTEXT_NAME), outputAst.handler, 'b',\n          () => error('Unexpected interpolation'));\n\n      const statements = [\n        ...listenerScope.restoreViewStatement(), ...listenerScope.variableDeclarations(),\n        ...bindingExpr.render3Stmts\n      ];\n\n      const handler = o.fn(\n          [new o.FnParam('$event', o.DYNAMIC_TYPE)], statements, o.INFERRED_TYPE, null,\n          functionName);\n\n      return [o.literal(outputAst.name), handler];\n    };\n  }\n}\n\nexport class ValueConverter extends AstMemoryEfficientTransformer {\n  private _pipeBindExprs: FunctionCall[] = [];\n\n  constructor(\n      private constantPool: ConstantPool, private allocateSlot: () => number,\n      private allocatePureFunctionSlots: (numSlots: number) => number,\n      private definePipe:\n          (name: string, localName: string, slot: number, value: o.Expression) => void) {\n    super();\n  }\n\n  // AstMemoryEfficientTransformer\n  visitPipe(pipe: BindingPipe, context: any): AST {\n    // Allocate a slot to create the pipe\n    const slot = this.allocateSlot();\n    const slotPseudoLocal = `PIPE:${slot}`;\n    // Allocate one slot for the result plus one slot per pipe argument\n    const pureFunctionSlot = this.allocatePureFunctionSlots(2 + pipe.args.length);\n    const target = new PropertyRead(pipe.span, new ImplicitReceiver(pipe.span), slotPseudoLocal);\n    const {identifier, isVarLength} = pipeBindingCallInfo(pipe.args);\n    this.definePipe(pipe.name, slotPseudoLocal, slot, o.importExpr(identifier));\n    const args: AST[] = [pipe.exp, ...pipe.args];\n    const convertedArgs: AST[] =\n        isVarLength ? this.visitAll([new LiteralArray(pipe.span, args)]) : this.visitAll(args);\n\n    const pipeBindExpr = new FunctionCall(pipe.span, target, [\n      new LiteralPrimitive(pipe.span, slot),\n      new LiteralPrimitive(pipe.span, pureFunctionSlot),\n      ...convertedArgs,\n    ]);\n    this._pipeBindExprs.push(pipeBindExpr);\n    return pipeBindExpr;\n  }\n\n  updatePipeSlotOffsets(bindingSlots: number) {\n    this._pipeBindExprs.forEach((pipe: FunctionCall) => {\n      // update the slot offset arg (index 1) to account for binding slots\n      const slotOffset = pipe.args[1] as LiteralPrimitive;\n      (slotOffset.value as number) += bindingSlots;\n    });\n  }\n\n  visitLiteralArray(array: LiteralArray, context: any): AST {\n    return new BuiltinFunctionCall(array.span, this.visitAll(array.expressions), values => {\n      // If the literal has calculated (non-literal) elements transform it into\n      // calls to literal factories that compose the literal and will cache intermediate\n      // values. Otherwise, just return an literal array that contains the values.\n      const literal = o.literalArr(values);\n      return values.every(a => a.isConstant()) ?\n          this.constantPool.getConstLiteral(literal, true) :\n          getLiteralFactory(this.constantPool, literal, this.allocatePureFunctionSlots);\n    });\n  }\n\n  visitLiteralMap(map: LiteralMap, context: any): AST {\n    return new BuiltinFunctionCall(map.span, this.visitAll(map.values), values => {\n      // If the literal has calculated (non-literal) elements  transform it into\n      // calls to literal factories that compose the literal and will cache intermediate\n      // values. Otherwise, just return an literal array that contains the values.\n      const literal = o.literalMap(values.map(\n          (value, index) => ({key: map.keys[index].key, value, quoted: map.keys[index].quoted})));\n      return values.every(a => a.isConstant()) ?\n          this.constantPool.getConstLiteral(literal, true) :\n          getLiteralFactory(this.constantPool, literal, this.allocatePureFunctionSlots);\n    });\n  }\n}\n\n// Pipes always have at least one parameter, the value they operate on\nconst pipeBindingIdentifiers = [R3.pipeBind1, R3.pipeBind2, R3.pipeBind3, R3.pipeBind4];\n\nfunction pipeBindingCallInfo(args: o.Expression[]) {\n  const identifier = pipeBindingIdentifiers[args.length];\n  return {\n    identifier: identifier || R3.pipeBindV,\n    isVarLength: !identifier,\n  };\n}\n\nconst pureFunctionIdentifiers = [\n  R3.pureFunction0, R3.pureFunction1, R3.pureFunction2, R3.pureFunction3, R3.pureFunction4,\n  R3.pureFunction5, R3.pureFunction6, R3.pureFunction7, R3.pureFunction8\n];\n\nfunction pureFunctionCallInfo(args: o.Expression[]) {\n  const identifier = pureFunctionIdentifiers[args.length];\n  return {\n    identifier: identifier || R3.pureFunctionV,\n    isVarLength: !identifier,\n  };\n}\n\nfunction instruction(\n    span: ParseSourceSpan | null, reference: o.ExternalReference,\n    params: o.Expression[]): o.Expression {\n  return o.importExpr(reference, null, span).callFn(params, span);\n}\n\n// e.g. x(2);\nfunction generateNextContextExpr(relativeLevelDiff: number): o.Expression {\n  return o.importExpr(R3.nextContext)\n      .callFn(relativeLevelDiff > 1 ? [o.literal(relativeLevelDiff)] : []);\n}\n\nfunction getLiteralFactory(\n    constantPool: ConstantPool, literal: o.LiteralArrayExpr | o.LiteralMapExpr,\n    allocateSlots: (numSlots: number) => number): o.Expression {\n  const {literalFactory, literalFactoryArguments} = constantPool.getLiteralFactory(literal);\n  // Allocate 1 slot for the result plus 1 per argument\n  const startSlot = allocateSlots(1 + literalFactoryArguments.length);\n  literalFactoryArguments.length > 0 || error(`Expected arguments to a literal factory function`);\n  const {identifier, isVarLength} = pureFunctionCallInfo(literalFactoryArguments);\n\n  // Literal factories are pure functions that only need to be re-invoked when the parameters\n  // change.\n  const args = [\n    o.literal(startSlot),\n    literalFactory,\n  ];\n\n  if (isVarLength) {\n    args.push(o.literalArr(literalFactoryArguments));\n  } else {\n    args.push(...literalFactoryArguments);\n  }\n\n  return o.importExpr(identifier).callFn(args);\n}\n\n/**\n * Function which is executed whenever a variable is referenced for the first time in a given\n * scope.\n *\n * It is expected that the function creates the `const localName = expression`; statement.\n */\nexport type DeclareLocalVarCallback = (scope: BindingScope, relativeLevel: number) => o.Statement[];\n\n/** The prefix used to get a shared context in BindingScope's map. */\nconst SHARED_CONTEXT_KEY = '$$shared_ctx$$';\n\n/**\n * This is used when one refers to variable such as: 'let abc = x(2).$implicit`.\n * - key to the map is the string literal `\"abc\"`.\n * - value `retrievalLevel` is the level from which this value can be retrieved, which is 2 levels\n * up in example.\n * - value `lhs` is the left hand side which is an AST representing `abc`.\n * - value `declareLocalCallback` is a callback that is invoked when declaring the local.\n * - value `declare` is true if this value needs to be declared.\n * - value `priority` dictates the sorting priority of this var declaration compared\n * to other var declarations on the same retrieval level. For example, if there is a\n * context variable and a local ref accessing the same parent view, the context var\n * declaration should always come before the local ref declaration.\n */\ntype BindingData = {\n  retrievalLevel: number; lhs: o.ReadVarExpr; declareLocalCallback?: DeclareLocalVarCallback;\n  declare: boolean;\n  priority: number;\n};\n\n/**\n * The sorting priority of a local variable declaration. Higher numbers\n * mean the declaration will appear first in the generated code.\n */\nconst enum DeclarationPriority { DEFAULT = 0, CONTEXT = 1, SHARED_CONTEXT = 2 }\n\nexport class BindingScope implements LocalResolver {\n  /** Keeps a map from local variables to their BindingData. */\n  private map = new Map<string, BindingData>();\n  private referenceNameIndex = 0;\n  private restoreViewVariable: o.ReadVarExpr|null = null;\n  private static _ROOT_SCOPE: BindingScope;\n\n  static get ROOT_SCOPE(): BindingScope {\n    if (!BindingScope._ROOT_SCOPE) {\n      BindingScope._ROOT_SCOPE = new BindingScope().set(0, '$event', o.variable('$event'));\n    }\n    return BindingScope._ROOT_SCOPE;\n  }\n\n  private constructor(public bindingLevel: number = 0, private parent: BindingScope|null = null) {}\n\n  get(name: string): o.Expression|null {\n    let current: BindingScope|null = this;\n    while (current) {\n      let value = current.map.get(name);\n      if (value != null) {\n        if (current !== this) {\n          // make a local copy and reset the `declare` state\n          value = {\n            retrievalLevel: value.retrievalLevel,\n            lhs: value.lhs,\n            declareLocalCallback: value.declareLocalCallback,\n            declare: false,\n            priority: value.priority\n          };\n\n          // Cache the value locally.\n          this.map.set(name, value);\n          // Possibly generate a shared context var\n          this.maybeGenerateSharedContextVar(value);\n          this.maybeRestoreView(value.retrievalLevel);\n        }\n\n        if (value.declareLocalCallback && !value.declare) {\n          value.declare = true;\n        }\n        return value.lhs;\n      }\n      current = current.parent;\n    }\n\n    // If we get to this point, we are looking for a property on the top level component\n    // - If level === 0, we are on the top and don't need to re-declare `ctx`.\n    // - If level > 0, we are in an embedded view. We need to retrieve the name of the\n    // local var we used to store the component context, e.g. const $comp$ = x();\n    return this.bindingLevel === 0 ? null : this.getComponentProperty(name);\n  }\n\n  /**\n   * Create a local variable for later reference.\n   *\n   * @param retrievalLevel The level from which this value can be retrieved\n   * @param name Name of the variable.\n   * @param lhs AST representing the left hand side of the `let lhs = rhs;`.\n   * @param priority The sorting priority of this var\n   * @param declareLocalCallback The callback to invoke when declaring this local var\n   */\n  set(retrievalLevel: number, name: string, lhs: o.ReadVarExpr,\n      priority: number = DeclarationPriority.DEFAULT,\n      declareLocalCallback?: DeclareLocalVarCallback): BindingScope {\n    !this.map.has(name) ||\n        error(`The name ${name} is already defined in scope to be ${this.map.get(name)}`);\n    this.map.set(name, {\n      retrievalLevel: retrievalLevel,\n      lhs: lhs,\n      declare: false,\n      declareLocalCallback: declareLocalCallback,\n      priority: priority\n    });\n    return this;\n  }\n\n  getLocal(name: string): (o.Expression|null) { return this.get(name); }\n\n  nestedScope(level: number): BindingScope {\n    const newScope = new BindingScope(level, this);\n    if (level > 0) newScope.generateSharedContextVar(0);\n    return newScope;\n  }\n\n  getSharedContextName(retrievalLevel: number): o.ReadVarExpr|null {\n    const sharedCtxObj = this.map.get(SHARED_CONTEXT_KEY + retrievalLevel);\n    return sharedCtxObj && sharedCtxObj.declare ? sharedCtxObj.lhs : null;\n  }\n\n  maybeGenerateSharedContextVar(value: BindingData) {\n    if (value.priority === DeclarationPriority.CONTEXT) {\n      const sharedCtxObj = this.map.get(SHARED_CONTEXT_KEY + value.retrievalLevel);\n      if (sharedCtxObj) {\n        sharedCtxObj.declare = true;\n      } else {\n        this.generateSharedContextVar(value.retrievalLevel);\n      }\n    }\n  }\n\n  generateSharedContextVar(retrievalLevel: number) {\n    const lhs = o.variable(CONTEXT_NAME + this.freshReferenceName());\n    this.map.set(SHARED_CONTEXT_KEY + retrievalLevel, {\n      retrievalLevel: retrievalLevel,\n      lhs: lhs,\n      declareLocalCallback: (scope: BindingScope, relativeLevel: number) => {\n        // const ctx_r0 = x(2);\n        return [lhs.set(generateNextContextExpr(relativeLevel)).toConstDecl()];\n      },\n      declare: false,\n      priority: DeclarationPriority.SHARED_CONTEXT\n    });\n  }\n\n  getComponentProperty(name: string): o.Expression {\n    const componentValue = this.map.get(SHARED_CONTEXT_KEY + 0) !;\n    componentValue.declare = true;\n    this.maybeRestoreView(0);\n    return componentValue.lhs.prop(name);\n  }\n\n  maybeRestoreView(retrievalLevel: number) {\n    if (this.isListenerScope() && retrievalLevel < this.bindingLevel) {\n      if (!this.parent !.restoreViewVariable) {\n        // parent saves variable to generate a shared `const $s$ = gV();` instruction\n        this.parent !.restoreViewVariable = o.variable(this.parent !.freshReferenceName());\n      }\n      this.restoreViewVariable = this.parent !.restoreViewVariable;\n    }\n  }\n\n  restoreViewStatement(): o.Statement[] {\n    // rV($state$);\n    return this.restoreViewVariable ?\n        [instruction(null, R3.restoreView, [this.restoreViewVariable]).toStmt()] :\n        [];\n  }\n\n  viewSnapshotStatements(): o.Statement[] {\n    // const $state$ = gV();\n    const getCurrentViewInstruction = instruction(null, R3.getCurrentView, []);\n    return this.restoreViewVariable ?\n        [this.restoreViewVariable.set(getCurrentViewInstruction).toConstDecl()] :\n        [];\n  }\n\n  isListenerScope() { return this.parent && this.parent.bindingLevel === this.bindingLevel; }\n\n  variableDeclarations(): o.Statement[] {\n    let currentContextLevel = 0;\n    return Array.from(this.map.values())\n        .filter(value => value.declare)\n        .sort((a, b) => b.retrievalLevel - a.retrievalLevel || b.priority - a.priority)\n        .reduce((stmts: o.Statement[], value: BindingData) => {\n          const levelDiff = this.bindingLevel - value.retrievalLevel;\n          const currStmts = value.declareLocalCallback !(this, levelDiff - currentContextLevel);\n          currentContextLevel = levelDiff;\n          return stmts.concat(currStmts);\n        }, []) as o.Statement[];\n  }\n\n\n  freshReferenceName(): string {\n    let current: BindingScope = this;\n    // Find the top scope as it maintains the global reference count\n    while (current.parent) current = current.parent;\n    const ref = `${REFERENCE_PREFIX}${current.referenceNameIndex++}`;\n    return ref;\n  }\n}\n\n/**\n * Creates a `CssSelector` given a tag name and a map of attributes\n */\nfunction createCssSelector(tag: string, attributes: {[name: string]: string}): CssSelector {\n  const cssSelector = new CssSelector();\n\n  cssSelector.setElement(tag);\n\n  Object.getOwnPropertyNames(attributes).forEach((name) => {\n    const value = attributes[name];\n\n    cssSelector.addAttribute(name, value);\n    if (name.toLowerCase() === 'class') {\n      const classes = value.trim().split(/\\s+/g);\n      classes.forEach(className => cssSelector.addClassName(className));\n    }\n  });\n\n  return cssSelector;\n}\n\nfunction interpolate(args: o.Expression[]): o.Expression {\n  args = args.slice(1);  // Ignore the length prefix added for render2\n  switch (args.length) {\n    case 3:\n      return o.importExpr(R3.interpolation1).callFn(args);\n    case 5:\n      return o.importExpr(R3.interpolation2).callFn(args);\n    case 7:\n      return o.importExpr(R3.interpolation3).callFn(args);\n    case 9:\n      return o.importExpr(R3.interpolation4).callFn(args);\n    case 11:\n      return o.importExpr(R3.interpolation5).callFn(args);\n    case 13:\n      return o.importExpr(R3.interpolation6).callFn(args);\n    case 15:\n      return o.importExpr(R3.interpolation7).callFn(args);\n    case 17:\n      return o.importExpr(R3.interpolation8).callFn(args);\n  }\n  (args.length >= 19 && args.length % 2 == 1) ||\n      error(`Invalid interpolation argument length ${args.length}`);\n  return o.importExpr(R3.interpolationV).callFn([o.literalArr(args)]);\n}\n\n/**\n * Parse a template into render3 `Node`s and additional metadata, with no other dependencies.\n *\n * @param template text of the template to parse\n * @param templateUrl URL to use for source mapping of the parsed template\n */\nexport function parseTemplate(\n    template: string, templateUrl: string, options: {preserveWhitespaces?: boolean} = {},\n    relativeContextFilePath: string): {\n  errors?: ParseError[],\n  nodes: t.Node[],\n  hasNgContent: boolean,\n  ngContentSelectors: string[],\n  relativeContextFilePath: string\n} {\n  const bindingParser = makeBindingParser();\n  const htmlParser = new HtmlParser();\n  const parseResult = htmlParser.parse(template, templateUrl);\n\n  if (parseResult.errors && parseResult.errors.length > 0) {\n    return {\n      errors: parseResult.errors,\n      nodes: [],\n      hasNgContent: false,\n      ngContentSelectors: [], relativeContextFilePath\n    };\n  }\n\n  let rootNodes: html.Node[] = parseResult.rootNodes;\n  if (!options.preserveWhitespaces) {\n    rootNodes = html.visitAll(new WhitespaceVisitor(), rootNodes);\n  }\n\n  const {nodes, hasNgContent, ngContentSelectors, errors} =\n      htmlAstToRender3Ast(rootNodes, bindingParser);\n  if (errors && errors.length > 0) {\n    return {\n      errors,\n      nodes: [],\n      hasNgContent: false,\n      ngContentSelectors: [], relativeContextFilePath\n    };\n  }\n\n  return {nodes, hasNgContent, ngContentSelectors, relativeContextFilePath};\n}\n\n/**\n * Construct a `BindingParser` with a default configuration.\n */\nexport function makeBindingParser(): BindingParser {\n  return new BindingParser(\n      new Parser(new Lexer()), DEFAULT_INTERPOLATION_CONFIG, new DomElementSchemaRegistry(), null,\n      []);\n}\n\nfunction isClassBinding(input: t.BoundAttribute): boolean {\n  return input.name == 'className' || input.name == 'class';\n}\n\nfunction resolveSanitizationFn(input: t.BoundAttribute, context: core.SecurityContext) {\n  switch (context) {\n    case core.SecurityContext.HTML:\n      return o.importExpr(R3.sanitizeHtml);\n    case core.SecurityContext.SCRIPT:\n      return o.importExpr(R3.sanitizeScript);\n    case core.SecurityContext.STYLE:\n      // the compiler does not fill in an instruction for [style.prop?] binding\n      // values because the style algorithm knows internally what props are subject\n      // to sanitization (only [attr.style] values are explicitly sanitized)\n      return input.type === BindingType.Attribute ? o.importExpr(R3.sanitizeStyle) : null;\n    case core.SecurityContext.URL:\n      return o.importExpr(R3.sanitizeUrl);\n    case core.SecurityContext.RESOURCE_URL:\n      return o.importExpr(R3.sanitizeResourceUrl);\n    default:\n      return null;\n  }\n}\n\nfunction isStyleSanitizable(prop: string): boolean {\n  switch (prop) {\n    case 'background-image':\n    case 'background':\n    case 'border-image':\n    case 'filter':\n    case 'list-style':\n    case 'list-style-image':\n      return true;\n  }\n  return false;\n}\n\nfunction prepareSyntheticAttributeName(name: string) {\n  return '@' + name;\n}\n"]}