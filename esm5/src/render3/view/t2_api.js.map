{"version":3,"file":"t2_api.js","sourceRoot":"","sources":["../../../../../../../packages/compiler/src/render3/view/t2_api.ts"],"names":[],"mappings":"AAAA;;;;;;GAMG","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {AST} from '../../expression_parser/ast';\n\nimport {BoundAttribute, BoundEvent, Element, Node, Reference, Template, TextAttribute, Variable} from '../r3_ast';\n\n/*\n * t2 is the replacement for the `TemplateDefinitionBuilder`. It handles the operations of\n * analyzing Angular templates, extracting semantic info, and ultimately producing a template\n * definition function which renders the template using Ivy instructions.\n *\n * t2 data is also utilized by the template type-checking facilities to understand a template enough\n * to generate type-checking code for it.\n */\n\n/**\n * A logical target for analysis, which could contain a template or other types of bindings.\n */\nexport interface Target { template?: Node[]; }\n\n/**\n * Metadata regarding a directive that's needed to match it against template elements. This is\n * provided by a consumer of the t2 APIs.\n */\nexport interface DirectiveMeta {\n  /**\n   * Name of the directive class (used for debugging).\n   */\n  name: string;\n\n  /**\n   * Whether the directive is a component.\n   */\n  isComponent: boolean;\n\n  /**\n   * Set of inputs which this directive claims.\n   *\n   * Goes from property names to field names.\n   */\n  inputs: {[property: string]: string | [string, string]};\n\n  /**\n   * Set of outputs which this directive claims.\n   *\n   * Goes from property names to field names.\n   */\n  outputs: {[property: string]: string};\n\n  /**\n   * Name under which the directive is exported, if any (exportAs in Angular).\n   *\n   * Null otherwise\n   */\n  exportAs: string|null;\n}\n\n/**\n * Interface to the binding API, which processes a template and returns an object similar to the\n * `ts.TypeChecker`.\n *\n * The returned `BoundTarget` has an API for extracting information about the processed target.\n */\nexport interface TargetBinder<D extends DirectiveMeta> { bind(target: Target): BoundTarget<D>; }\n\n/**\n * Result of performing the binding operation against a `Target`.\n *\n * The original `Target` is accessible, as well as a suite of methods for extracting binding\n * information regarding the `Target`.\n *\n * @param DirectiveT directive metadata type\n */\nexport interface BoundTarget<DirectiveT extends DirectiveMeta> {\n  /**\n   * Get the original `Target` that was bound.\n   */\n  readonly target: Target;\n\n  /**\n   * For a given template node (either an `Element` or a `Template`), get the set of directives\n   * which matched the node, if any.\n   */\n  getDirectivesOfNode(node: Element|Template): DirectiveT[]|null;\n\n  /**\n   * For a given `Reference`, get the reference's target - either an `Element`, a `Template`, or\n   * a directive on a particular node.\n   */\n  getReferenceTarget(ref: Reference): {directive: DirectiveT, node: Element|Template}|Element\n      |Template|null;\n\n  /**\n   * For a given binding, get the entity to which the binding is being made.\n   *\n   * This will either be a directive or the node itself.\n   */\n  getConsumerOfBinding(binding: BoundAttribute|BoundEvent|TextAttribute): DirectiveT|Element\n      |Template|null;\n\n  /**\n   * If the given `AST` expression refers to a `Reference` or `Variable` within the `Target`, then\n   * return that.\n   *\n   * Otherwise, returns `null`.\n   *\n   * This is only defined for `AST` expressions that read or write to a property of an\n   * `ImplicitReceiver`.\n   */\n  getExpressionTarget(expr: AST): Reference|Variable|null;\n\n  /**\n   * Given a particular `Reference` or `Variable`, get the `Template` which created it.\n   *\n   * All `Variable`s are defined on templates, so this will always return a value for a `Variable`\n   * from the `Target`. For `Reference`s this only returns a value if the `Reference` points to a\n   * `Template`. Returns `null` otherwise.\n   */\n  getTemplateOfSymbol(symbol: Reference|Variable): Template|null;\n\n  /**\n   * Get the nesting level of a particular `Template`.\n   *\n   * This starts at 1 for top-level `Template`s within the `Target` and increases for `Template`s\n   * nested at deeper levels.\n   */\n  getNestingLevel(template: Template): number;\n\n  /**\n   * Get a list of all the directives used by the target.\n   */\n  getUsedDirectives(): DirectiveT[];\n}\n"]}