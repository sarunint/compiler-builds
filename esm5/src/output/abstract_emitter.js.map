{"version":3,"file":"abstract_emitter.js","sourceRoot":"","sources":["../../../../../../packages/compiler/src/output/abstract_emitter.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ParseSourceSpan} from '../parse_util';\n\nimport * as o from './output_ast';\nimport {SourceMapGenerator} from './source_map';\n\nconst _SINGLE_QUOTE_ESCAPE_STRING_RE = /'|\\\\|\\n|\\r|\\$/g;\nconst _LEGAL_IDENTIFIER_RE = /^[$A-Z_][0-9A-Z_$]*$/i;\nconst _INDENT_WITH = '  ';\nexport const CATCH_ERROR_VAR = o.variable('error', null, null);\nexport const CATCH_STACK_VAR = o.variable('stack', null, null);\n\nexport interface OutputEmitter {\n  emitStatements(genFilePath: string, stmts: o.Statement[], preamble?: string|null): string;\n}\n\nclass _EmittedLine {\n  partsLength = 0;\n  parts: string[] = [];\n  srcSpans: (ParseSourceSpan|null)[] = [];\n  constructor(public indent: number) {}\n}\n\nexport class EmitterVisitorContext {\n  static createRoot(): EmitterVisitorContext { return new EmitterVisitorContext(0); }\n\n  private _lines: _EmittedLine[];\n  private _classes: o.ClassStmt[] = [];\n  private _preambleLineCount = 0;\n\n  constructor(private _indent: number) { this._lines = [new _EmittedLine(_indent)]; }\n\n  private get _currentLine(): _EmittedLine { return this._lines[this._lines.length - 1]; }\n\n  println(from?: {sourceSpan: ParseSourceSpan | null}|null, lastPart: string = ''): void {\n    this.print(from || null, lastPart, true);\n  }\n\n  lineIsEmpty(): boolean { return this._currentLine.parts.length === 0; }\n\n  lineLength(): number {\n    return this._currentLine.indent * _INDENT_WITH.length + this._currentLine.partsLength;\n  }\n\n  print(from: {sourceSpan: ParseSourceSpan | null}|null, part: string, newLine: boolean = false) {\n    if (part.length > 0) {\n      this._currentLine.parts.push(part);\n      this._currentLine.partsLength += part.length;\n      this._currentLine.srcSpans.push(from && from.sourceSpan || null);\n    }\n    if (newLine) {\n      this._lines.push(new _EmittedLine(this._indent));\n    }\n  }\n\n  removeEmptyLastLine() {\n    if (this.lineIsEmpty()) {\n      this._lines.pop();\n    }\n  }\n\n  incIndent() {\n    this._indent++;\n    if (this.lineIsEmpty()) {\n      this._currentLine.indent = this._indent;\n    }\n  }\n\n  decIndent() {\n    this._indent--;\n    if (this.lineIsEmpty()) {\n      this._currentLine.indent = this._indent;\n    }\n  }\n\n  pushClass(clazz: o.ClassStmt) { this._classes.push(clazz); }\n\n  popClass(): o.ClassStmt { return this._classes.pop() !; }\n\n  get currentClass(): o.ClassStmt|null {\n    return this._classes.length > 0 ? this._classes[this._classes.length - 1] : null;\n  }\n\n  toSource(): string {\n    return this.sourceLines\n        .map(l => l.parts.length > 0 ? _createIndent(l.indent) + l.parts.join('') : '')\n        .join('\\n');\n  }\n\n  toSourceMapGenerator(genFilePath: string, startsAtLine: number = 0): SourceMapGenerator {\n    const map = new SourceMapGenerator(genFilePath);\n\n    let firstOffsetMapped = false;\n    const mapFirstOffsetIfNeeded = () => {\n      if (!firstOffsetMapped) {\n        // Add a single space so that tools won't try to load the file from disk.\n        // Note: We are using virtual urls like `ng:///`, so we have to\n        // provide a content here.\n        map.addSource(genFilePath, ' ').addMapping(0, genFilePath, 0, 0);\n        firstOffsetMapped = true;\n      }\n    };\n\n    for (let i = 0; i < startsAtLine; i++) {\n      map.addLine();\n      mapFirstOffsetIfNeeded();\n    }\n\n    this.sourceLines.forEach((line, lineIdx) => {\n      map.addLine();\n\n      const spans = line.srcSpans;\n      const parts = line.parts;\n      let col0 = line.indent * _INDENT_WITH.length;\n      let spanIdx = 0;\n      // skip leading parts without source spans\n      while (spanIdx < spans.length && !spans[spanIdx]) {\n        col0 += parts[spanIdx].length;\n        spanIdx++;\n      }\n      if (spanIdx < spans.length && lineIdx === 0 && col0 === 0) {\n        firstOffsetMapped = true;\n      } else {\n        mapFirstOffsetIfNeeded();\n      }\n\n      while (spanIdx < spans.length) {\n        const span = spans[spanIdx] !;\n        const source = span.start.file;\n        const sourceLine = span.start.line;\n        const sourceCol = span.start.col;\n        map.addSource(source.url, source.content)\n            .addMapping(col0, source.url, sourceLine, sourceCol);\n\n        col0 += parts[spanIdx].length;\n        spanIdx++;\n\n        // assign parts without span or the same span to the previous segment\n        while (spanIdx < spans.length && (span === spans[spanIdx] || !spans[spanIdx])) {\n          col0 += parts[spanIdx].length;\n          spanIdx++;\n        }\n      }\n    });\n\n    return map;\n  }\n\n  setPreambleLineCount(count: number) { return this._preambleLineCount = count; }\n\n  spanOf(line: number, column: number): ParseSourceSpan|null {\n    const emittedLine = this._lines[line - this._preambleLineCount];\n    if (emittedLine) {\n      let columnsLeft = column - _createIndent(emittedLine.indent).length;\n      for (let partIndex = 0; partIndex < emittedLine.parts.length; partIndex++) {\n        const part = emittedLine.parts[partIndex];\n        if (part.length > columnsLeft) {\n          return emittedLine.srcSpans[partIndex];\n        }\n        columnsLeft -= part.length;\n      }\n    }\n    return null;\n  }\n\n  private get sourceLines(): _EmittedLine[] {\n    if (this._lines.length && this._lines[this._lines.length - 1].parts.length === 0) {\n      return this._lines.slice(0, -1);\n    }\n    return this._lines;\n  }\n}\n\nexport abstract class AbstractEmitterVisitor implements o.StatementVisitor, o.ExpressionVisitor {\n  constructor(private _escapeDollarInStrings: boolean) {}\n\n  visitExpressionStmt(stmt: o.ExpressionStatement, ctx: EmitterVisitorContext): any {\n    stmt.expr.visitExpression(this, ctx);\n    ctx.println(stmt, ';');\n    return null;\n  }\n\n  visitReturnStmt(stmt: o.ReturnStatement, ctx: EmitterVisitorContext): any {\n    ctx.print(stmt, `return `);\n    stmt.value.visitExpression(this, ctx);\n    ctx.println(stmt, ';');\n    return null;\n  }\n\n  abstract visitCastExpr(ast: o.CastExpr, context: any): any;\n\n  abstract visitDeclareClassStmt(stmt: o.ClassStmt, ctx: EmitterVisitorContext): any;\n\n  visitIfStmt(stmt: o.IfStmt, ctx: EmitterVisitorContext): any {\n    ctx.print(stmt, `if (`);\n    stmt.condition.visitExpression(this, ctx);\n    ctx.print(stmt, `) {`);\n    const hasElseCase = stmt.falseCase != null && stmt.falseCase.length > 0;\n    if (stmt.trueCase.length <= 1 && !hasElseCase) {\n      ctx.print(stmt, ` `);\n      this.visitAllStatements(stmt.trueCase, ctx);\n      ctx.removeEmptyLastLine();\n      ctx.print(stmt, ` `);\n    } else {\n      ctx.println();\n      ctx.incIndent();\n      this.visitAllStatements(stmt.trueCase, ctx);\n      ctx.decIndent();\n      if (hasElseCase) {\n        ctx.println(stmt, `} else {`);\n        ctx.incIndent();\n        this.visitAllStatements(stmt.falseCase, ctx);\n        ctx.decIndent();\n      }\n    }\n    ctx.println(stmt, `}`);\n    return null;\n  }\n\n  abstract visitTryCatchStmt(stmt: o.TryCatchStmt, ctx: EmitterVisitorContext): any;\n\n  visitThrowStmt(stmt: o.ThrowStmt, ctx: EmitterVisitorContext): any {\n    ctx.print(stmt, `throw `);\n    stmt.error.visitExpression(this, ctx);\n    ctx.println(stmt, `;`);\n    return null;\n  }\n  visitCommentStmt(stmt: o.CommentStmt, ctx: EmitterVisitorContext): any {\n    if (stmt.multiline) {\n      ctx.println(stmt, `/* ${stmt.comment} */`);\n    } else {\n      stmt.comment.split('\\n').forEach((line) => { ctx.println(stmt, `// ${line}`); });\n    }\n    return null;\n  }\n  visitJSDocCommentStmt(stmt: o.JSDocCommentStmt, ctx: EmitterVisitorContext) {\n    ctx.println(stmt, `/*${stmt.toString()}*/`);\n    return null;\n  }\n\n  abstract visitDeclareVarStmt(stmt: o.DeclareVarStmt, ctx: EmitterVisitorContext): any;\n\n  visitWriteVarExpr(expr: o.WriteVarExpr, ctx: EmitterVisitorContext): any {\n    const lineWasEmpty = ctx.lineIsEmpty();\n    if (!lineWasEmpty) {\n      ctx.print(expr, '(');\n    }\n    ctx.print(expr, `${expr.name} = `);\n    expr.value.visitExpression(this, ctx);\n    if (!lineWasEmpty) {\n      ctx.print(expr, ')');\n    }\n    return null;\n  }\n  visitWriteKeyExpr(expr: o.WriteKeyExpr, ctx: EmitterVisitorContext): any {\n    const lineWasEmpty = ctx.lineIsEmpty();\n    if (!lineWasEmpty) {\n      ctx.print(expr, '(');\n    }\n    expr.receiver.visitExpression(this, ctx);\n    ctx.print(expr, `[`);\n    expr.index.visitExpression(this, ctx);\n    ctx.print(expr, `] = `);\n    expr.value.visitExpression(this, ctx);\n    if (!lineWasEmpty) {\n      ctx.print(expr, ')');\n    }\n    return null;\n  }\n  visitWritePropExpr(expr: o.WritePropExpr, ctx: EmitterVisitorContext): any {\n    const lineWasEmpty = ctx.lineIsEmpty();\n    if (!lineWasEmpty) {\n      ctx.print(expr, '(');\n    }\n    expr.receiver.visitExpression(this, ctx);\n    ctx.print(expr, `.${expr.name} = `);\n    expr.value.visitExpression(this, ctx);\n    if (!lineWasEmpty) {\n      ctx.print(expr, ')');\n    }\n    return null;\n  }\n  visitInvokeMethodExpr(expr: o.InvokeMethodExpr, ctx: EmitterVisitorContext): any {\n    expr.receiver.visitExpression(this, ctx);\n    let name = expr.name;\n    if (expr.builtin != null) {\n      name = this.getBuiltinMethodName(expr.builtin);\n      if (name == null) {\n        // some builtins just mean to skip the call.\n        return null;\n      }\n    }\n    ctx.print(expr, `.${name}(`);\n    this.visitAllExpressions(expr.args, ctx, `,`);\n    ctx.print(expr, `)`);\n    return null;\n  }\n\n  abstract getBuiltinMethodName(method: o.BuiltinMethod): string;\n\n  visitInvokeFunctionExpr(expr: o.InvokeFunctionExpr, ctx: EmitterVisitorContext): any {\n    expr.fn.visitExpression(this, ctx);\n    ctx.print(expr, `(`);\n    this.visitAllExpressions(expr.args, ctx, ',');\n    ctx.print(expr, `)`);\n    return null;\n  }\n  visitWrappedNodeExpr(ast: o.WrappedNodeExpr<any>, ctx: EmitterVisitorContext): any {\n    throw new Error('Abstract emitter cannot visit WrappedNodeExpr.');\n  }\n  visitTypeofExpr(expr: o.TypeofExpr, ctx: EmitterVisitorContext): any {\n    ctx.print(expr, 'typeof ');\n    expr.expr.visitExpression(this, ctx);\n  }\n  visitReadVarExpr(ast: o.ReadVarExpr, ctx: EmitterVisitorContext): any {\n    let varName = ast.name !;\n    if (ast.builtin != null) {\n      switch (ast.builtin) {\n        case o.BuiltinVar.Super:\n          varName = 'super';\n          break;\n        case o.BuiltinVar.This:\n          varName = 'this';\n          break;\n        case o.BuiltinVar.CatchError:\n          varName = CATCH_ERROR_VAR.name !;\n          break;\n        case o.BuiltinVar.CatchStack:\n          varName = CATCH_STACK_VAR.name !;\n          break;\n        default:\n          throw new Error(`Unknown builtin variable ${ast.builtin}`);\n      }\n    }\n    ctx.print(ast, varName);\n    return null;\n  }\n  visitInstantiateExpr(ast: o.InstantiateExpr, ctx: EmitterVisitorContext): any {\n    ctx.print(ast, `new `);\n    ast.classExpr.visitExpression(this, ctx);\n    ctx.print(ast, `(`);\n    this.visitAllExpressions(ast.args, ctx, ',');\n    ctx.print(ast, `)`);\n    return null;\n  }\n\n  visitLiteralExpr(ast: o.LiteralExpr, ctx: EmitterVisitorContext): any {\n    const value = ast.value;\n    if (typeof value === 'string') {\n      ctx.print(ast, escapeIdentifier(value, this._escapeDollarInStrings));\n    } else {\n      ctx.print(ast, `${value}`);\n    }\n    return null;\n  }\n\n  abstract visitExternalExpr(ast: o.ExternalExpr, ctx: EmitterVisitorContext): any;\n\n  visitConditionalExpr(ast: o.ConditionalExpr, ctx: EmitterVisitorContext): any {\n    ctx.print(ast, `(`);\n    ast.condition.visitExpression(this, ctx);\n    ctx.print(ast, '? ');\n    ast.trueCase.visitExpression(this, ctx);\n    ctx.print(ast, ': ');\n    ast.falseCase !.visitExpression(this, ctx);\n    ctx.print(ast, `)`);\n    return null;\n  }\n  visitNotExpr(ast: o.NotExpr, ctx: EmitterVisitorContext): any {\n    ctx.print(ast, '!');\n    ast.condition.visitExpression(this, ctx);\n    return null;\n  }\n  visitAssertNotNullExpr(ast: o.AssertNotNull, ctx: EmitterVisitorContext): any {\n    ast.condition.visitExpression(this, ctx);\n    return null;\n  }\n  abstract visitFunctionExpr(ast: o.FunctionExpr, ctx: EmitterVisitorContext): any;\n  abstract visitDeclareFunctionStmt(stmt: o.DeclareFunctionStmt, context: any): any;\n\n  visitBinaryOperatorExpr(ast: o.BinaryOperatorExpr, ctx: EmitterVisitorContext): any {\n    let opStr: string;\n    switch (ast.operator) {\n      case o.BinaryOperator.Equals:\n        opStr = '==';\n        break;\n      case o.BinaryOperator.Identical:\n        opStr = '===';\n        break;\n      case o.BinaryOperator.NotEquals:\n        opStr = '!=';\n        break;\n      case o.BinaryOperator.NotIdentical:\n        opStr = '!==';\n        break;\n      case o.BinaryOperator.And:\n        opStr = '&&';\n        break;\n      case o.BinaryOperator.BitwiseAnd:\n        opStr = '&';\n        break;\n      case o.BinaryOperator.Or:\n        opStr = '||';\n        break;\n      case o.BinaryOperator.Plus:\n        opStr = '+';\n        break;\n      case o.BinaryOperator.Minus:\n        opStr = '-';\n        break;\n      case o.BinaryOperator.Divide:\n        opStr = '/';\n        break;\n      case o.BinaryOperator.Multiply:\n        opStr = '*';\n        break;\n      case o.BinaryOperator.Modulo:\n        opStr = '%';\n        break;\n      case o.BinaryOperator.Lower:\n        opStr = '<';\n        break;\n      case o.BinaryOperator.LowerEquals:\n        opStr = '<=';\n        break;\n      case o.BinaryOperator.Bigger:\n        opStr = '>';\n        break;\n      case o.BinaryOperator.BiggerEquals:\n        opStr = '>=';\n        break;\n      default:\n        throw new Error(`Unknown operator ${ast.operator}`);\n    }\n    if (ast.parens) ctx.print(ast, `(`);\n    ast.lhs.visitExpression(this, ctx);\n    ctx.print(ast, ` ${opStr} `);\n    ast.rhs.visitExpression(this, ctx);\n    if (ast.parens) ctx.print(ast, `)`);\n    return null;\n  }\n\n  visitReadPropExpr(ast: o.ReadPropExpr, ctx: EmitterVisitorContext): any {\n    ast.receiver.visitExpression(this, ctx);\n    ctx.print(ast, `.`);\n    ctx.print(ast, ast.name);\n    return null;\n  }\n  visitReadKeyExpr(ast: o.ReadKeyExpr, ctx: EmitterVisitorContext): any {\n    ast.receiver.visitExpression(this, ctx);\n    ctx.print(ast, `[`);\n    ast.index.visitExpression(this, ctx);\n    ctx.print(ast, `]`);\n    return null;\n  }\n  visitLiteralArrayExpr(ast: o.LiteralArrayExpr, ctx: EmitterVisitorContext): any {\n    ctx.print(ast, `[`);\n    this.visitAllExpressions(ast.entries, ctx, ',');\n    ctx.print(ast, `]`);\n    return null;\n  }\n  visitLiteralMapExpr(ast: o.LiteralMapExpr, ctx: EmitterVisitorContext): any {\n    ctx.print(ast, `{`);\n    this.visitAllObjects(entry => {\n      ctx.print(ast, `${escapeIdentifier(entry.key, this._escapeDollarInStrings, entry.quoted)}:`);\n      entry.value.visitExpression(this, ctx);\n    }, ast.entries, ctx, ',');\n    ctx.print(ast, `}`);\n    return null;\n  }\n  visitCommaExpr(ast: o.CommaExpr, ctx: EmitterVisitorContext): any {\n    ctx.print(ast, '(');\n    this.visitAllExpressions(ast.parts, ctx, ',');\n    ctx.print(ast, ')');\n    return null;\n  }\n  visitAllExpressions(expressions: o.Expression[], ctx: EmitterVisitorContext, separator: string):\n      void {\n    this.visitAllObjects(expr => expr.visitExpression(this, ctx), expressions, ctx, separator);\n  }\n\n  visitAllObjects<T>(\n      handler: (t: T) => void, expressions: T[], ctx: EmitterVisitorContext,\n      separator: string): void {\n    let incrementedIndent = false;\n    for (let i = 0; i < expressions.length; i++) {\n      if (i > 0) {\n        if (ctx.lineLength() > 80) {\n          ctx.print(null, separator, true);\n          if (!incrementedIndent) {\n            // continuation are marked with double indent.\n            ctx.incIndent();\n            ctx.incIndent();\n            incrementedIndent = true;\n          }\n        } else {\n          ctx.print(null, separator, false);\n        }\n      }\n      handler(expressions[i]);\n    }\n    if (incrementedIndent) {\n      // continuation are marked with double indent.\n      ctx.decIndent();\n      ctx.decIndent();\n    }\n  }\n\n  visitAllStatements(statements: o.Statement[], ctx: EmitterVisitorContext): void {\n    statements.forEach((stmt) => stmt.visitStatement(this, ctx));\n  }\n}\n\nexport function escapeIdentifier(\n    input: string, escapeDollar: boolean, alwaysQuote: boolean = true): any {\n  if (input == null) {\n    return null;\n  }\n  const body = input.replace(_SINGLE_QUOTE_ESCAPE_STRING_RE, (...match: string[]) => {\n    if (match[0] == '$') {\n      return escapeDollar ? '\\\\$' : '$';\n    } else if (match[0] == '\\n') {\n      return '\\\\n';\n    } else if (match[0] == '\\r') {\n      return '\\\\r';\n    } else {\n      return `\\\\${match[0]}`;\n    }\n  });\n  const requiresQuotes = alwaysQuote || !_LEGAL_IDENTIFIER_RE.test(body);\n  return requiresQuotes ? `'${body}'` : body;\n}\n\nfunction _createIndent(count: number): string {\n  let res = '';\n  for (let i = 0; i < count; i++) {\n    res += _INDENT_WITH;\n  }\n  return res;\n}\n"]}