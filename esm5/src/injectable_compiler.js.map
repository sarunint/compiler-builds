{"version":3,"file":"injectable_compiler.js","sourceRoot":"","sources":["../../../../../packages/compiler/src/injectable_compiler.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {StaticSymbol} from './aot/static_symbol';\nimport {CompileInjectableMetadata, CompileNgModuleMetadata, CompileProviderMetadata, identifierName} from './compile_metadata';\nimport {CompileReflector} from './compile_reflector';\nimport {InjectFlags, NodeFlags} from './core';\nimport {Identifiers} from './identifiers';\nimport * as o from './output/output_ast';\nimport {convertValueToOutputAst} from './output/value_util';\nimport {typeSourceSpan} from './parse_util';\nimport {NgModuleProviderAnalyzer} from './provider_analyzer';\nimport {OutputContext} from './util';\nimport {componentFactoryResolverProviderDef, depDef, providerDef} from './view_compiler/provider_compiler';\n\ntype MapEntry = {\n  key: string,\n  quoted: boolean,\n  value: o.Expression\n};\ntype MapLiteral = MapEntry[];\n\nfunction mapEntry(key: string, value: o.Expression): MapEntry {\n  return {key, value, quoted: false};\n}\n\nexport class InjectableCompiler {\n  private tokenInjector: StaticSymbol;\n  constructor(private reflector: CompileReflector, private alwaysGenerateDef: boolean) {\n    this.tokenInjector = reflector.resolveExternalReference(Identifiers.Injector);\n  }\n\n  private depsArray(deps: any[], ctx: OutputContext): o.Expression[] {\n    return deps.map(dep => {\n      let token = dep;\n      let args = [token];\n      let flags: InjectFlags = InjectFlags.Default;\n      if (Array.isArray(dep)) {\n        for (let i = 0; i < dep.length; i++) {\n          const v = dep[i];\n          if (v) {\n            if (v.ngMetadataName === 'Optional') {\n              flags |= InjectFlags.Optional;\n            } else if (v.ngMetadataName === 'SkipSelf') {\n              flags |= InjectFlags.SkipSelf;\n            } else if (v.ngMetadataName === 'Self') {\n              flags |= InjectFlags.Self;\n            } else if (v.ngMetadataName === 'Inject') {\n              token = v.token;\n            } else {\n              token = v;\n            }\n          }\n        }\n      }\n\n      let tokenExpr: o.Expression;\n      if (typeof token === 'string') {\n        tokenExpr = o.literal(token);\n      } else if (token === this.tokenInjector) {\n        tokenExpr = o.importExpr(Identifiers.INJECTOR);\n      } else {\n        tokenExpr = ctx.importExpr(token);\n      }\n\n      if (flags !== InjectFlags.Default) {\n        args = [tokenExpr, o.literal(flags)];\n      } else {\n        args = [tokenExpr];\n      }\n      return o.importExpr(Identifiers.inject).callFn(args);\n    });\n  }\n\n  factoryFor(injectable: CompileInjectableMetadata, ctx: OutputContext): o.Expression {\n    let retValue: o.Expression;\n    if (injectable.useExisting) {\n      retValue = o.importExpr(Identifiers.inject).callFn([ctx.importExpr(injectable.useExisting)]);\n    } else if (injectable.useFactory) {\n      const deps = injectable.deps || [];\n      if (deps.length > 0) {\n        retValue = ctx.importExpr(injectable.useFactory).callFn(this.depsArray(deps, ctx));\n      } else {\n        return ctx.importExpr(injectable.useFactory);\n      }\n    } else if (injectable.useValue) {\n      retValue = convertValueToOutputAst(ctx, injectable.useValue);\n    } else {\n      const clazz = injectable.useClass || injectable.symbol;\n      const depArgs = this.depsArray(this.reflector.parameters(clazz), ctx);\n      retValue = new o.InstantiateExpr(ctx.importExpr(clazz), depArgs);\n    }\n    return o.fn(\n        [], [new o.ReturnStatement(retValue)], undefined, undefined,\n        injectable.symbol.name + '_Factory');\n  }\n\n  injectableDef(injectable: CompileInjectableMetadata, ctx: OutputContext): o.Expression {\n    let providedIn: o.Expression = o.NULL_EXPR;\n    if (injectable.providedIn !== undefined) {\n      if (injectable.providedIn === null) {\n        providedIn = o.NULL_EXPR;\n      } else if (typeof injectable.providedIn === 'string') {\n        providedIn = o.literal(injectable.providedIn);\n      } else {\n        providedIn = ctx.importExpr(injectable.providedIn);\n      }\n    }\n    const def: MapLiteral = [\n      mapEntry('factory', this.factoryFor(injectable, ctx)),\n      mapEntry('token', ctx.importExpr(injectable.type.reference)),\n      mapEntry('providedIn', providedIn),\n    ];\n    return o.importExpr(Identifiers.defineInjectable).callFn([o.literalMap(def)]);\n  }\n\n  compile(injectable: CompileInjectableMetadata, ctx: OutputContext): void {\n    if (this.alwaysGenerateDef || injectable.providedIn !== undefined) {\n      const className = identifierName(injectable.type) !;\n      const clazz = new o.ClassStmt(\n          className, null,\n          [\n            new o.ClassField(\n                'ngInjectableDef', o.INFERRED_TYPE, [o.StmtModifier.Static],\n                this.injectableDef(injectable, ctx)),\n          ],\n          [], new o.ClassMethod(null, [], []), []);\n      ctx.statements.push(clazz);\n    }\n  }\n}\n"]}