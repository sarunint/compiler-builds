{"version":3,"file":"ast_path.js","sourceRoot":"","sources":["../../../../../packages/compiler/src/ast_path.ts"],"names":[],"mappings":"AAAA;;;;;;GAMG;AAEH;;;;;;;;;;;;;;;;GAgBG;AACH;IACE,iBAAoB,IAAS,EAAS,QAAqB;QAArB,yBAAA,EAAA,YAAoB,CAAC;QAAvC,SAAI,GAAJ,IAAI,CAAK;QAAS,aAAQ,GAAR,QAAQ,CAAa;IAAG,CAAC;IAE/D,sBAAI,0BAAK;aAAT,cAAuB,OAAO,CAAC,IAAI,CAAC,IAAI,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC;;;OAAA;IAChE,sBAAI,yBAAI;aAAR,cAA0B,OAAO,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;;;OAAA;IAChD,sBAAI,yBAAI;aAAR,cAA0B,OAAO,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;;;OAAA;IAEnE,0BAAQ,GAAR,UAAS,IAAiB;QACxB,OAAO,IAAI,IAAI,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC;IACxD,CAAC;IACD,yBAAO,GAAP,UAAQ,IAAO,IAAiB,OAAO,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;IAEhF,uBAAK,GAAL,UAAmB,IAA+B;QAChD,KAAK,IAAI,CAAC,GAAG,IAAI,CAAC,IAAI,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC,IAAI,CAAC,EAAE,CAAC,EAAE,EAAE;YAC9C,IAAI,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;YACxB,IAAI,IAAI,YAAY,IAAI;gBAAE,OAAU,IAAI,CAAC;SAC1C;IACH,CAAC;IAED,sBAAI,GAAJ,UAAK,IAAO,IAAI,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;IAEvC,qBAAG,GAAH,cAAW,OAAO,IAAI,CAAC,IAAI,CAAC,GAAG,EAAI,CAAC,CAAC,CAAC;IACxC,cAAC;AAAD,CAAC,AAtBD,IAsBC","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * A path is an ordered set of elements. Typically a path is to  a\n * particular offset in a source file. The head of the list is the top\n * most node. The tail is the node that contains the offset directly.\n *\n * For example, the expression `a + b + c` might have an ast that looks\n * like:\n *     +\n *    / \\\n *   a   +\n *      / \\\n *     b   c\n *\n * The path to the node at offset 9 would be `['+' at 1-10, '+' at 7-10,\n * 'c' at 9-10]` and the path the node at offset 1 would be\n * `['+' at 1-10, 'a' at 1-2]`.\n */\nexport class AstPath<T> {\n  constructor(private path: T[], public position: number = -1) {}\n\n  get empty(): boolean { return !this.path || !this.path.length; }\n  get head(): T|undefined { return this.path[0]; }\n  get tail(): T|undefined { return this.path[this.path.length - 1]; }\n\n  parentOf(node: T|undefined): T|undefined {\n    return node && this.path[this.path.indexOf(node) - 1];\n  }\n  childOf(node: T): T|undefined { return this.path[this.path.indexOf(node) + 1]; }\n\n  first<N extends T>(ctor: {new (...args: any[]): N}): N|undefined {\n    for (let i = this.path.length - 1; i >= 0; i--) {\n      let item = this.path[i];\n      if (item instanceof ctor) return <N>item;\n    }\n  }\n\n  push(node: T) { this.path.push(node); }\n\n  pop(): T { return this.path.pop() !; }\n}\n"]}