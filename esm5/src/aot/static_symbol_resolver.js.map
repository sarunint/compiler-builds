{"version":3,"file":"static_symbol_resolver.js","sourceRoot":"","sources":["../../../../../../packages/compiler/src/aot/static_symbol_resolver.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {SummaryResolver} from '../summary_resolver';\nimport {ValueTransformer, visitValue} from '../util';\n\nimport {StaticSymbol, StaticSymbolCache} from './static_symbol';\nimport {isGeneratedFile, stripSummaryForJitFileSuffix, stripSummaryForJitNameSuffix, summaryForJitFileName, summaryForJitName} from './util';\n\nconst TS = /^(?!.*\\.d\\.ts$).*\\.ts$/;\n\nexport class ResolvedStaticSymbol {\n  constructor(public symbol: StaticSymbol, public metadata: any) {}\n}\n\n/**\n * The host of the SymbolResolverHost disconnects the implementation from TypeScript / other\n * language\n * services and from underlying file systems.\n */\nexport interface StaticSymbolResolverHost {\n  /**\n   * Return a ModuleMetadata for the given module.\n   * Angular CLI will produce this metadata for a module whenever a .d.ts files is\n   * produced and the module has exported variables or classes with decorators. Module metadata can\n   * also be produced directly from TypeScript sources by using MetadataCollector in tools/metadata.\n   *\n   * @param modulePath is a string identifier for a module as an absolute path.\n   * @returns the metadata for the given module.\n   */\n  getMetadataFor(modulePath: string): {[key: string]: any}[]|undefined;\n\n  /**\n   * Converts a module name that is used in an `import` to a file path.\n   * I.e.\n   * `path/to/containingFile.ts` containing `import {...} from 'module-name'`.\n   */\n  moduleNameToFileName(moduleName: string, containingFile?: string): string|null;\n\n  /**\n   * Get a file suitable for display to the user that should be relative to the project directory\n   * or the current directory.\n   */\n  getOutputName(filePath: string): string;\n}\n\nconst SUPPORTED_SCHEMA_VERSION = 4;\n\n/**\n * This class is responsible for loading metadata per symbol,\n * and normalizing references between symbols.\n *\n * Internally, it only uses symbols without members,\n * and deduces the values for symbols with members based\n * on these symbols.\n */\nexport class StaticSymbolResolver {\n  private metadataCache = new Map<string, {[key: string]: any}>();\n  // Note: this will only contain StaticSymbols without members!\n  private resolvedSymbols = new Map<StaticSymbol, ResolvedStaticSymbol>();\n  private resolvedFilePaths = new Set<string>();\n  // Note: this will only contain StaticSymbols without members!\n  private importAs = new Map<StaticSymbol, StaticSymbol>();\n  private symbolResourcePaths = new Map<StaticSymbol, string>();\n  private symbolFromFile = new Map<string, StaticSymbol[]>();\n  private knownFileNameToModuleNames = new Map<string, string>();\n\n  constructor(\n      private host: StaticSymbolResolverHost, private staticSymbolCache: StaticSymbolCache,\n      private summaryResolver: SummaryResolver<StaticSymbol>,\n      private errorRecorder?: (error: any, fileName?: string) => void) {}\n\n  resolveSymbol(staticSymbol: StaticSymbol): ResolvedStaticSymbol {\n    if (staticSymbol.members.length > 0) {\n      return this._resolveSymbolMembers(staticSymbol) !;\n    }\n    // Note: always ask for a summary first,\n    // as we might have read shallow metadata via a .d.ts file\n    // for the symbol.\n    const resultFromSummary = this._resolveSymbolFromSummary(staticSymbol) !;\n    if (resultFromSummary) {\n      return resultFromSummary;\n    }\n    const resultFromCache = this.resolvedSymbols.get(staticSymbol);\n    if (resultFromCache) {\n      return resultFromCache;\n    }\n    // Note: Some users use libraries that were not compiled with ngc, i.e. they don't\n    // have summaries, only .d.ts files. So we always need to check both, the summary\n    // and metadata.\n    this._createSymbolsOf(staticSymbol.filePath);\n    return this.resolvedSymbols.get(staticSymbol) !;\n  }\n\n  /**\n   * getImportAs produces a symbol that can be used to import the given symbol.\n   * The import might be different than the symbol if the symbol is exported from\n   * a library with a summary; in which case we want to import the symbol from the\n   * ngfactory re-export instead of directly to avoid introducing a direct dependency\n   * on an otherwise indirect dependency.\n   *\n   * @param staticSymbol the symbol for which to generate a import symbol\n   */\n  getImportAs(staticSymbol: StaticSymbol, useSummaries: boolean = true): StaticSymbol|null {\n    if (staticSymbol.members.length) {\n      const baseSymbol = this.getStaticSymbol(staticSymbol.filePath, staticSymbol.name);\n      const baseImportAs = this.getImportAs(baseSymbol, useSummaries);\n      return baseImportAs ?\n          this.getStaticSymbol(baseImportAs.filePath, baseImportAs.name, staticSymbol.members) :\n          null;\n    }\n    const summarizedFileName = stripSummaryForJitFileSuffix(staticSymbol.filePath);\n    if (summarizedFileName !== staticSymbol.filePath) {\n      const summarizedName = stripSummaryForJitNameSuffix(staticSymbol.name);\n      const baseSymbol =\n          this.getStaticSymbol(summarizedFileName, summarizedName, staticSymbol.members);\n      const baseImportAs = this.getImportAs(baseSymbol, useSummaries);\n      return baseImportAs ?\n          this.getStaticSymbol(\n              summaryForJitFileName(baseImportAs.filePath), summaryForJitName(baseImportAs.name),\n              baseSymbol.members) :\n          null;\n    }\n    let result = (useSummaries && this.summaryResolver.getImportAs(staticSymbol)) || null;\n    if (!result) {\n      result = this.importAs.get(staticSymbol) !;\n    }\n    return result;\n  }\n\n  /**\n   * getResourcePath produces the path to the original location of the symbol and should\n   * be used to determine the relative location of resource references recorded in\n   * symbol metadata.\n   */\n  getResourcePath(staticSymbol: StaticSymbol): string {\n    return this.symbolResourcePaths.get(staticSymbol) || staticSymbol.filePath;\n  }\n\n  /**\n   * getTypeArity returns the number of generic type parameters the given symbol\n   * has. If the symbol is not a type the result is null.\n   */\n  getTypeArity(staticSymbol: StaticSymbol): number|null {\n    // If the file is a factory/ngsummary file, don't resolve the symbol as doing so would\n    // cause the metadata for an factory/ngsummary file to be loaded which doesn't exist.\n    // All references to generated classes must include the correct arity whenever\n    // generating code.\n    if (isGeneratedFile(staticSymbol.filePath)) {\n      return null;\n    }\n    let resolvedSymbol = unwrapResolvedMetadata(this.resolveSymbol(staticSymbol));\n    while (resolvedSymbol && resolvedSymbol.metadata instanceof StaticSymbol) {\n      resolvedSymbol = unwrapResolvedMetadata(this.resolveSymbol(resolvedSymbol.metadata));\n    }\n    return (resolvedSymbol && resolvedSymbol.metadata && resolvedSymbol.metadata.arity) || null;\n  }\n\n  getKnownModuleName(filePath: string): string|null {\n    return this.knownFileNameToModuleNames.get(filePath) || null;\n  }\n\n  recordImportAs(sourceSymbol: StaticSymbol, targetSymbol: StaticSymbol) {\n    sourceSymbol.assertNoMembers();\n    targetSymbol.assertNoMembers();\n    this.importAs.set(sourceSymbol, targetSymbol);\n  }\n\n  recordModuleNameForFileName(fileName: string, moduleName: string) {\n    this.knownFileNameToModuleNames.set(fileName, moduleName);\n  }\n\n  /**\n   * Invalidate all information derived from the given file.\n   *\n   * @param fileName the file to invalidate\n   */\n  invalidateFile(fileName: string) {\n    this.metadataCache.delete(fileName);\n    this.resolvedFilePaths.delete(fileName);\n    const symbols = this.symbolFromFile.get(fileName);\n    if (symbols) {\n      this.symbolFromFile.delete(fileName);\n      for (const symbol of symbols) {\n        this.resolvedSymbols.delete(symbol);\n        this.importAs.delete(symbol);\n        this.symbolResourcePaths.delete(symbol);\n      }\n    }\n  }\n\n  /** @internal */\n  ignoreErrorsFor<T>(cb: () => T) {\n    const recorder = this.errorRecorder;\n    this.errorRecorder = () => {};\n    try {\n      return cb();\n    } finally {\n      this.errorRecorder = recorder;\n    }\n  }\n\n  private _resolveSymbolMembers(staticSymbol: StaticSymbol): ResolvedStaticSymbol|null {\n    const members = staticSymbol.members;\n    const baseResolvedSymbol =\n        this.resolveSymbol(this.getStaticSymbol(staticSymbol.filePath, staticSymbol.name));\n    if (!baseResolvedSymbol) {\n      return null;\n    }\n    let baseMetadata = unwrapResolvedMetadata(baseResolvedSymbol.metadata);\n    if (baseMetadata instanceof StaticSymbol) {\n      return new ResolvedStaticSymbol(\n          staticSymbol, this.getStaticSymbol(baseMetadata.filePath, baseMetadata.name, members));\n    } else if (baseMetadata && baseMetadata.__symbolic === 'class') {\n      if (baseMetadata.statics && members.length === 1) {\n        return new ResolvedStaticSymbol(staticSymbol, baseMetadata.statics[members[0]]);\n      }\n    } else {\n      let value = baseMetadata;\n      for (let i = 0; i < members.length && value; i++) {\n        value = value[members[i]];\n      }\n      return new ResolvedStaticSymbol(staticSymbol, value);\n    }\n    return null;\n  }\n\n  private _resolveSymbolFromSummary(staticSymbol: StaticSymbol): ResolvedStaticSymbol|null {\n    const summary = this.summaryResolver.resolveSummary(staticSymbol);\n    return summary ? new ResolvedStaticSymbol(staticSymbol, summary.metadata) : null;\n  }\n\n  /**\n   * getStaticSymbol produces a Type whose metadata is known but whose implementation is not loaded.\n   * All types passed to the StaticResolver should be pseudo-types returned by this method.\n   *\n   * @param declarationFile the absolute path of the file where the symbol is declared\n   * @param name the name of the type.\n   * @param members a symbol for a static member of the named type\n   */\n  getStaticSymbol(declarationFile: string, name: string, members?: string[]): StaticSymbol {\n    return this.staticSymbolCache.get(declarationFile, name, members);\n  }\n\n  /**\n   * hasDecorators checks a file's metadata for the presence of decorators without evaluating the\n   * metadata.\n   *\n   * @param filePath the absolute path to examine for decorators.\n   * @returns true if any class in the file has a decorator.\n   */\n  hasDecorators(filePath: string): boolean {\n    const metadata = this.getModuleMetadata(filePath);\n    if (metadata['metadata']) {\n      return Object.keys(metadata['metadata']).some((metadataKey) => {\n        const entry = metadata['metadata'][metadataKey];\n        return entry && entry.__symbolic === 'class' && entry.decorators;\n      });\n    }\n    return false;\n  }\n\n  getSymbolsOf(filePath: string): StaticSymbol[] {\n    const summarySymbols = this.summaryResolver.getSymbolsOf(filePath);\n    if (summarySymbols) {\n      return summarySymbols;\n    }\n    // Note: Some users use libraries that were not compiled with ngc, i.e. they don't\n    // have summaries, only .d.ts files, but `summaryResolver.isLibraryFile` returns true.\n    this._createSymbolsOf(filePath);\n    const metadataSymbols: StaticSymbol[] = [];\n    this.resolvedSymbols.forEach((resolvedSymbol) => {\n      if (resolvedSymbol.symbol.filePath === filePath) {\n        metadataSymbols.push(resolvedSymbol.symbol);\n      }\n    });\n    return metadataSymbols;\n  }\n\n  private _createSymbolsOf(filePath: string) {\n    if (this.resolvedFilePaths.has(filePath)) {\n      return;\n    }\n    this.resolvedFilePaths.add(filePath);\n    const resolvedSymbols: ResolvedStaticSymbol[] = [];\n    const metadata = this.getModuleMetadata(filePath);\n    if (metadata['importAs']) {\n      // Index bundle indices should use the importAs module name defined\n      // in the bundle.\n      this.knownFileNameToModuleNames.set(filePath, metadata['importAs']);\n    }\n    // handle the symbols in one of the re-export location\n    if (metadata['exports']) {\n      for (const moduleExport of metadata['exports']) {\n        // handle the symbols in the list of explicitly re-exported symbols.\n        if (moduleExport.export) {\n          moduleExport.export.forEach((exportSymbol: any) => {\n            let symbolName: string;\n            if (typeof exportSymbol === 'string') {\n              symbolName = exportSymbol;\n            } else {\n              symbolName = exportSymbol.as;\n            }\n            symbolName = unescapeIdentifier(symbolName);\n            let symName = symbolName;\n            if (typeof exportSymbol !== 'string') {\n              symName = unescapeIdentifier(exportSymbol.name);\n            }\n            const resolvedModule = this.resolveModule(moduleExport.from, filePath);\n            if (resolvedModule) {\n              const targetSymbol = this.getStaticSymbol(resolvedModule, symName);\n              const sourceSymbol = this.getStaticSymbol(filePath, symbolName);\n              resolvedSymbols.push(this.createExport(sourceSymbol, targetSymbol));\n            }\n          });\n        } else {\n          // handle the symbols via export * directives.\n          const resolvedModule = this.resolveModule(moduleExport.from, filePath);\n          if (resolvedModule) {\n            const nestedExports = this.getSymbolsOf(resolvedModule);\n            nestedExports.forEach((targetSymbol) => {\n              const sourceSymbol = this.getStaticSymbol(filePath, targetSymbol.name);\n              resolvedSymbols.push(this.createExport(sourceSymbol, targetSymbol));\n            });\n          }\n        }\n      }\n    }\n\n    // handle the actual metadata. Has to be after the exports\n    // as there might be collisions in the names, and we want the symbols\n    // of the current module to win ofter reexports.\n    if (metadata['metadata']) {\n      // handle direct declarations of the symbol\n      const topLevelSymbolNames =\n          new Set<string>(Object.keys(metadata['metadata']).map(unescapeIdentifier));\n      const origins: {[index: string]: string} = metadata['origins'] || {};\n      Object.keys(metadata['metadata']).forEach((metadataKey) => {\n        const symbolMeta = metadata['metadata'][metadataKey];\n        const name = unescapeIdentifier(metadataKey);\n\n        const symbol = this.getStaticSymbol(filePath, name);\n\n        const origin = origins.hasOwnProperty(metadataKey) && origins[metadataKey];\n        if (origin) {\n          // If the symbol is from a bundled index, use the declaration location of the\n          // symbol so relative references (such as './my.html') will be calculated\n          // correctly.\n          const originFilePath = this.resolveModule(origin, filePath);\n          if (!originFilePath) {\n            this.reportError(new Error(\n                `Couldn't resolve original symbol for ${origin} from ${this.host.getOutputName(filePath)}`));\n          } else {\n            this.symbolResourcePaths.set(symbol, originFilePath);\n          }\n        }\n        resolvedSymbols.push(\n            this.createResolvedSymbol(symbol, filePath, topLevelSymbolNames, symbolMeta));\n      });\n    }\n    resolvedSymbols.forEach(\n        (resolvedSymbol) => this.resolvedSymbols.set(resolvedSymbol.symbol, resolvedSymbol));\n    this.symbolFromFile.set(filePath, resolvedSymbols.map(resolvedSymbol => resolvedSymbol.symbol));\n  }\n\n  private createResolvedSymbol(\n      sourceSymbol: StaticSymbol, topLevelPath: string, topLevelSymbolNames: Set<string>,\n      metadata: any): ResolvedStaticSymbol {\n    // For classes that don't have Angular summaries / metadata,\n    // we only keep their arity, but nothing else\n    // (e.g. their constructor parameters).\n    // We do this to prevent introducing deep imports\n    // as we didn't generate .ngfactory.ts files with proper reexports.\n    const isTsFile = TS.test(sourceSymbol.filePath);\n    if (this.summaryResolver.isLibraryFile(sourceSymbol.filePath) && !isTsFile && metadata &&\n        metadata['__symbolic'] === 'class') {\n      const transformedMeta = {__symbolic: 'class', arity: metadata.arity};\n      return new ResolvedStaticSymbol(sourceSymbol, transformedMeta);\n    }\n\n    let _originalFileMemo: string|undefined;\n    const getOriginalName: () => string = () => {\n      if (!_originalFileMemo) {\n        // Guess what the original file name is from the reference. If it has a `.d.ts` extension\n        // replace it with `.ts`. If it already has `.ts` just leave it in place. If it doesn't have\n        // .ts or .d.ts, append `.ts'. Also, if it is in `node_modules`, trim the `node_module`\n        // location as it is not important to finding the file.\n        _originalFileMemo =\n            this.host.getOutputName(topLevelPath.replace(/((\\.ts)|(\\.d\\.ts)|)$/, '.ts')\n                                        .replace(/^.*node_modules[/\\\\]/, ''));\n      }\n      return _originalFileMemo;\n    };\n\n    const self = this;\n\n    class ReferenceTransformer extends ValueTransformer {\n      visitStringMap(map: {[key: string]: any}, functionParams: string[]): any {\n        const symbolic = map['__symbolic'];\n        if (symbolic === 'function') {\n          const oldLen = functionParams.length;\n          functionParams.push(...(map['parameters'] || []));\n          const result = super.visitStringMap(map, functionParams);\n          functionParams.length = oldLen;\n          return result;\n        } else if (symbolic === 'reference') {\n          const module = map['module'];\n          const name = map['name'] ? unescapeIdentifier(map['name']) : map['name'];\n          if (!name) {\n            return null;\n          }\n          let filePath: string;\n          if (module) {\n            filePath = self.resolveModule(module, sourceSymbol.filePath) !;\n            if (!filePath) {\n              return {\n                __symbolic: 'error',\n                message:\n                    `Could not resolve ${module} relative to ${self.host.getMetadataFor(sourceSymbol.filePath)}.`,\n                line: map.line,\n                character: map.character,\n                fileName: getOriginalName()\n              };\n            }\n            return {\n              __symbolic: 'resolved',\n              symbol: self.getStaticSymbol(filePath, name),\n              line: map.line,\n              character: map.character,\n              fileName: getOriginalName()\n            };\n          } else if (functionParams.indexOf(name) >= 0) {\n            // reference to a function parameter\n            return {__symbolic: 'reference', name: name};\n          } else {\n            if (topLevelSymbolNames.has(name)) {\n              return self.getStaticSymbol(topLevelPath, name);\n            }\n            // ambient value\n            null;\n          }\n        } else if (symbolic === 'error') {\n          return {...map, fileName: getOriginalName()};\n        } else {\n          return super.visitStringMap(map, functionParams);\n        }\n      }\n    }\n    const transformedMeta = visitValue(metadata, new ReferenceTransformer(), []);\n    let unwrappedTransformedMeta = unwrapResolvedMetadata(transformedMeta);\n    if (unwrappedTransformedMeta instanceof StaticSymbol) {\n      return this.createExport(sourceSymbol, unwrappedTransformedMeta);\n    }\n    return new ResolvedStaticSymbol(sourceSymbol, transformedMeta);\n  }\n\n  private createExport(sourceSymbol: StaticSymbol, targetSymbol: StaticSymbol):\n      ResolvedStaticSymbol {\n    sourceSymbol.assertNoMembers();\n    targetSymbol.assertNoMembers();\n    if (this.summaryResolver.isLibraryFile(sourceSymbol.filePath) &&\n        this.summaryResolver.isLibraryFile(targetSymbol.filePath)) {\n      // This case is for an ng library importing symbols from a plain ts library\n      // transitively.\n      // Note: We rely on the fact that we discover symbols in the direction\n      // from source files to library files\n      this.importAs.set(targetSymbol, this.getImportAs(sourceSymbol) || sourceSymbol);\n    }\n    return new ResolvedStaticSymbol(sourceSymbol, targetSymbol);\n  }\n\n  private reportError(error: Error, context?: StaticSymbol, path?: string) {\n    if (this.errorRecorder) {\n      this.errorRecorder(error, (context && context.filePath) || path);\n    } else {\n      throw error;\n    }\n  }\n\n  /**\n   * @param module an absolute path to a module file.\n   */\n  private getModuleMetadata(module: string): {[key: string]: any} {\n    let moduleMetadata = this.metadataCache.get(module);\n    if (!moduleMetadata) {\n      const moduleMetadatas = this.host.getMetadataFor(module);\n      if (moduleMetadatas) {\n        let maxVersion = -1;\n        moduleMetadatas.forEach((md) => {\n          if (md && md['version'] > maxVersion) {\n            maxVersion = md['version'];\n            moduleMetadata = md;\n          }\n        });\n      }\n      if (!moduleMetadata) {\n        moduleMetadata =\n            {__symbolic: 'module', version: SUPPORTED_SCHEMA_VERSION, module: module, metadata: {}};\n      }\n      if (moduleMetadata['version'] != SUPPORTED_SCHEMA_VERSION) {\n        const errorMessage = moduleMetadata['version'] == 2 ?\n            `Unsupported metadata version ${moduleMetadata['version']} for module ${module}. This module should be compiled with a newer version of ngc` :\n            `Metadata version mismatch for module ${this.host.getOutputName(module)}, found version ${moduleMetadata['version']}, expected ${SUPPORTED_SCHEMA_VERSION}`;\n        this.reportError(new Error(errorMessage));\n      }\n      this.metadataCache.set(module, moduleMetadata);\n    }\n    return moduleMetadata;\n  }\n\n\n  getSymbolByModule(module: string, symbolName: string, containingFile?: string): StaticSymbol {\n    const filePath = this.resolveModule(module, containingFile);\n    if (!filePath) {\n      this.reportError(\n          new Error(`Could not resolve module ${module}${containingFile ? ' relative to ' +\n            this.host.getOutputName(containingFile) : ''}`));\n      return this.getStaticSymbol(`ERROR:${module}`, symbolName);\n    }\n    return this.getStaticSymbol(filePath, symbolName);\n  }\n\n  private resolveModule(module: string, containingFile?: string): string|null {\n    try {\n      return this.host.moduleNameToFileName(module, containingFile);\n    } catch (e) {\n      console.error(`Could not resolve module '${module}' relative to file ${containingFile}`);\n      this.reportError(e, undefined, containingFile);\n    }\n    return null;\n  }\n}\n\n// Remove extra underscore from escaped identifier.\n// See https://github.com/Microsoft/TypeScript/blob/master/src/compiler/utilities.ts\nexport function unescapeIdentifier(identifier: string): string {\n  return identifier.startsWith('___') ? identifier.substr(1) : identifier;\n}\n\nexport function unwrapResolvedMetadata(metadata: any): any {\n  if (metadata && metadata.__symbolic === 'resolved') {\n    return metadata.symbol;\n  }\n  return metadata;\n}\n"]}