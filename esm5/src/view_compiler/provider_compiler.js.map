{"version":3,"file":"provider_compiler.js","sourceRoot":"","sources":["../../../../../../packages/compiler/src/view_compiler/provider_compiler.ts"],"names":[],"mappings":"AAAA;;;;;;GAMG;AAKH,OAAO,EAAC,WAAW,EAAE,+BAA+B,EAAC,MAAM,gBAAgB,CAAC;AAC5E,OAAO,EAAC,cAAc,EAAC,MAAM,wBAAwB,CAAC;AACtD,OAAO,KAAK,CAAC,MAAM,sBAAsB,CAAC;AAC1C,OAAO,EAAC,uBAAuB,EAAC,MAAM,sBAAsB,CAAC;AAC7D,OAAO,EAAc,eAAe,EAAC,MAAM,iCAAiC,CAAC;AAG7E,MAAM,UAAU,WAAW,CAAC,GAAkB,EAAE,WAAwB;IAMtE,IAAI,KAAK,eAAiB,CAAC;IAC3B,IAAI,CAAC,WAAW,CAAC,KAAK,EAAE;QACtB,KAAK,2BAA0B,CAAC;KACjC;IACD,IAAI,WAAW,CAAC,YAAY,KAAK,eAAe,CAAC,cAAc,EAAE;QAC/D,KAAK,8BAA6B,CAAC;KACpC;IACD,IAAI,WAAW,CAAC,QAAQ,EAAE;QACxB,KAAK,uCAAgC,CAAC;KACvC;IACD,WAAW,CAAC,cAAc,CAAC,OAAO,CAAC,UAAC,aAAa;QAC/C,qDAAqD;QACrD,IAAI,aAAa,KAAK,cAAc,CAAC,SAAS;YAC1C,WAAW,CAAC,YAAY,KAAK,eAAe,CAAC,SAAS;YACtD,WAAW,CAAC,YAAY,KAAK,eAAe,CAAC,SAAS,EAAE;YAC1D,KAAK,IAAI,uBAAuB,CAAC,aAAa,CAAC,CAAC;SACjD;IACH,CAAC,CAAC,CAAC;IACG,IAAA;;yFAE+E,EAF9E,8BAAY,EAAE,wBAAoB,EAAE,sBAE0C,CAAC;IACtF,OAAO;QACL,YAAY,cAAA;QACZ,KAAK,EAAE,aAAa,EAAE,QAAQ,UAAA;QAC9B,SAAS,EAAE,SAAS,CAAC,GAAG,EAAE,WAAW,CAAC,KAAK,CAAC;KAC7C,CAAC;AACJ,CAAC;AAED,SAAS,gBAAgB,CACrB,GAAkB,EAAE,KAAgB,EAAE,SAAoC;IAE5E,IAAM,UAAU,GAAmB,EAAE,CAAC;IACtC,IAAM,SAAS,GAAgB,EAAE,CAAC;IAClC,IAAM,KAAK,GAAG,SAAS,CAAC,GAAG,CAAC,UAAC,QAAQ,EAAE,aAAa;QAClD,IAAI,IAAkB,CAAC;QACvB,IAAI,QAAQ,CAAC,QAAQ,EAAE;YACrB,IAAM,QAAQ,GAAG,WAAW,CAAC,aAAa,EAAE,QAAQ,CAAC,IAAI,IAAI,QAAQ,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC;YACvF,IAAI,GAAG,GAAG,CAAC,UAAU,CAAC,QAAQ,CAAC,QAAQ,CAAC,SAAS,CAAC,CAAC,WAAW,CAAC,QAAQ,CAAC,CAAC;SAC1E;aAAM,IAAI,QAAQ,CAAC,UAAU,EAAE;YAC9B,IAAM,QAAQ,GAAG,WAAW,CAAC,aAAa,EAAE,QAAQ,CAAC,IAAI,IAAI,QAAQ,CAAC,UAAU,CAAC,MAAM,CAAC,CAAC;YACzF,IAAI,GAAG,GAAG,CAAC,UAAU,CAAC,QAAQ,CAAC,UAAU,CAAC,SAAS,CAAC,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC;SACvE;aAAM,IAAI,QAAQ,CAAC,WAAW,EAAE;YAC/B,IAAM,QAAQ,GAAG,WAAW,CAAC,aAAa,EAAE,CAAC,EAAC,KAAK,EAAE,QAAQ,CAAC,WAAW,EAAC,CAAC,CAAC,CAAC;YAC7E,IAAI,GAAG,QAAQ,CAAC,CAAC,CAAC,CAAC;SACpB;aAAM;YACL,IAAI,GAAG,uBAAuB,CAAC,GAAG,EAAE,QAAQ,CAAC,QAAQ,CAAC,CAAC;SACxD;QACD,OAAO,IAAI,CAAC;IACd,CAAC,CAAC,CAAC;IACH,IAAM,YAAY,GACd,CAAC,CAAC,EAAE,CAAC,SAAS,EAAE,CAAC,IAAI,CAAC,CAAC,eAAe,CAAC,CAAC,CAAC,UAAU,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,aAAa,CAAC,CAAC;IACnF,OAAO;QACL,YAAY,cAAA;QACZ,KAAK,EAAE,KAAK,iCAAgC;QAC5C,QAAQ,EAAE,CAAC,CAAC,UAAU,CAAC,UAAU,CAAC;KACnC,CAAC;IAEF,SAAS,WAAW,CAAC,aAAqB,EAAE,IAAmC;QAC7E,OAAO,IAAI,CAAC,GAAG,CAAC,UAAC,GAAG,EAAE,QAAQ;YAC5B,IAAM,SAAS,GAAG,MAAI,aAAa,SAAI,QAAU,CAAC;YAClD,SAAS,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,OAAO,CAAC,SAAS,EAAE,CAAC,CAAC,YAAY,CAAC,CAAC,CAAC;YACzD,UAAU,CAAC,IAAI,CAAC,MAAM,CAAC,GAAG,EAAE,GAAG,CAAC,CAAC,CAAC;YAClC,OAAO,CAAC,CAAC,QAAQ,CAAC,SAAS,CAAC,CAAC;QAC/B,CAAC,CAAC,CAAC;IACL,CAAC;AACH,CAAC;AAED,SAAS,iBAAiB,CACtB,GAAkB,EAAE,KAAgB,EAAE,YAA6B,EACnE,YAAqC;IAEvC,IAAI,YAA0B,CAAC;IAC/B,IAAI,IAAmC,CAAC;IACxC,IAAI,YAAY,KAAK,eAAe,CAAC,SAAS,IAAI,YAAY,KAAK,eAAe,CAAC,SAAS,EAAE;QAC5F,YAAY,GAAG,GAAG,CAAC,UAAU,CAAC,YAAY,CAAC,QAAU,CAAC,SAAS,CAAC,CAAC;QACjE,KAAK,6BAA2B,CAAC;QACjC,IAAI,GAAG,YAAY,CAAC,IAAI,IAAI,YAAY,CAAC,QAAU,CAAC,MAAM,CAAC;KAC5D;SAAM;QACL,IAAI,YAAY,CAAC,QAAQ,EAAE;YACzB,YAAY,GAAG,GAAG,CAAC,UAAU,CAAC,YAAY,CAAC,QAAQ,CAAC,SAAS,CAAC,CAAC;YAC/D,KAAK,+BAA+B,CAAC;YACrC,IAAI,GAAG,YAAY,CAAC,IAAI,IAAI,YAAY,CAAC,QAAQ,CAAC,MAAM,CAAC;SAC1D;aAAM,IAAI,YAAY,CAAC,UAAU,EAAE;YAClC,YAAY,GAAG,GAAG,CAAC,UAAU,CAAC,YAAY,CAAC,UAAU,CAAC,SAAS,CAAC,CAAC;YACjE,KAAK,kCAAiC,CAAC;YACvC,IAAI,GAAG,YAAY,CAAC,IAAI,IAAI,YAAY,CAAC,UAAU,CAAC,MAAM,CAAC;SAC5D;aAAM,IAAI,YAAY,CAAC,WAAW,EAAE;YACnC,YAAY,GAAG,CAAC,CAAC,SAAS,CAAC;YAC3B,KAAK,sCAAqC,CAAC;YAC3C,IAAI,GAAG,CAAC,EAAC,KAAK,EAAE,YAAY,CAAC,WAAW,EAAC,CAAC,CAAC;SAC5C;aAAM;YACL,YAAY,GAAG,uBAAuB,CAAC,GAAG,EAAE,YAAY,CAAC,QAAQ,CAAC,CAAC;YACnE,KAAK,+BAA+B,CAAC;YACrC,IAAI,GAAG,EAAE,CAAC;SACX;KACF;IACD,IAAM,QAAQ,GAAG,CAAC,CAAC,UAAU,CAAC,IAAI,CAAC,GAAG,CAAC,UAAA,GAAG,IAAI,OAAA,MAAM,CAAC,GAAG,EAAE,GAAG,CAAC,EAAhB,CAAgB,CAAC,CAAC,CAAC;IACjE,OAAO,EAAC,YAAY,cAAA,EAAE,KAAK,OAAA,EAAE,QAAQ,UAAA,EAAC,CAAC;AACzC,CAAC;AAED,SAAS,SAAS,CAAC,GAAkB,EAAE,SAA+B;IACpE,OAAO,SAAS,CAAC,UAAU,CAAC,CAAC,CAAC,GAAG,CAAC,UAAU,CAAC,SAAS,CAAC,UAAU,CAAC,SAAS,CAAC,CAAC,CAAC;QAChD,CAAC,CAAC,OAAO,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC;AAC3D,CAAC;AAED,MAAM,UAAU,MAAM,CAAC,GAAkB,EAAE,GAAgC;IACzE,oFAAoF;IACpF,wBAAwB;IACxB,IAAM,IAAI,GAAG,GAAG,CAAC,OAAO,CAAC,CAAC,CAAC,uBAAuB,CAAC,GAAG,EAAE,GAAG,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC,GAAG,EAAE,GAAG,CAAC,KAAO,CAAC,CAAC;IACjG,IAAI,KAAK,eAAgB,CAAC;IAC1B,IAAI,GAAG,CAAC,UAAU,EAAE;QAClB,KAAK,oBAAqB,CAAC;KAC5B;IACD,IAAI,GAAG,CAAC,UAAU,EAAE;QAClB,KAAK,oBAAqB,CAAC;KAC5B;IACD,IAAI,GAAG,CAAC,MAAM,EAAE;QACd,KAAK,gBAAiB,CAAC;KACxB;IACD,IAAI,GAAG,CAAC,OAAO,EAAE;QACf,KAAK,iBAAkB,CAAC;KACzB;IACD,OAAO,KAAK,iBAAkB,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,KAAK,CAAC,EAAE,IAAI,CAAC,CAAC,CAAC;AACjF,CAAC;AAED,MAAM,UAAU,uBAAuB,CAAC,aAA6B;IACnE,IAAI,QAAQ,eAAiB,CAAC;IAC9B,QAAQ,aAAa,EAAE;QACrB,KAAK,cAAc,CAAC,mBAAmB;YACrC,QAAQ,oCAAgC,CAAC;YACzC,MAAM;QACR,KAAK,cAAc,CAAC,gBAAgB;YAClC,QAAQ,iCAA6B,CAAC;YACtC,MAAM;QACR,KAAK,cAAc,CAAC,gBAAgB;YAClC,QAAQ,iCAA6B,CAAC;YACtC,MAAM;QACR,KAAK,cAAc,CAAC,aAAa;YAC/B,QAAQ,8BAA0B,CAAC;YACnC,MAAM;QACR,KAAK,cAAc,CAAC,OAAO;YACzB,QAAQ,uBAAoB,CAAC;YAC7B,MAAM;QACR,KAAK,cAAc,CAAC,SAAS;YAC3B,QAAQ,yBAAsB,CAAC;YAC/B,MAAM;QACR,KAAK,cAAc,CAAC,SAAS;YAC3B,QAAQ,yBAAsB,CAAC;YAC/B,MAAM;QACR,KAAK,cAAc,CAAC,MAAM;YACxB,QAAQ,qBAAmB,CAAC;YAC5B,MAAM;KACT;IACD,OAAO,QAAQ,CAAC;AAClB,CAAC;AAED,MAAM,UAAU,mCAAmC,CAC/C,SAA2B,EAAE,GAAkB,EAAE,KAAgB,EACjE,eAAgD;IAMlD,IAAM,uBAAuB,GACzB,eAAe,CAAC,GAAG,CAAC,UAAC,cAAc,IAAK,OAAA,GAAG,CAAC,UAAU,CAAC,cAAc,CAAC,gBAAgB,CAAC,EAA/C,CAA+C,CAAC,CAAC;IAC7F,IAAM,KAAK,GAAG,+BAA+B,CAAC,SAAS,EAAE,WAAW,CAAC,wBAAwB,CAAC,CAAC;IAC/F,IAAM,SAAS,GAAG;QAChB,MAAM,EAAE;YACN,EAAC,OAAO,EAAE,IAAI,EAAE,KAAK,EAAE,CAAC,CAAC,UAAU,CAAC,uBAAuB,CAAC,EAAC;YAC7D,EAAC,KAAK,EAAE,KAAK,EAAE,UAAU,EAAE,IAAI,EAAE,UAAU,EAAE,IAAI,EAAC;YAClD,EAAC,KAAK,EAAE,+BAA+B,CAAC,SAAS,EAAE,WAAW,CAAC,WAAW,CAAC,EAAC;SAC7E;QACD,cAAc,EAAE,EAAE;QAClB,SAAS,EAAE,SAAS,CAAC,wBAAwB,CAAC,WAAW,CAAC,+BAA+B,CAAC;KAC3F,CAAC;IACI,IAAA;;;;MAKA,EALC,8BAAY,EAAE,wBAAoB,EAAE,sBAKrC,CAAC;IACP,OAAO,EAAC,YAAY,cAAA,EAAE,KAAK,EAAE,aAAa,EAAE,QAAQ,UAAA,EAAE,SAAS,EAAE,SAAS,CAAC,GAAG,EAAE,KAAK,CAAC,EAAC,CAAC;AAC1F,CAAC","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {CompileDiDependencyMetadata, CompileEntryComponentMetadata, CompileProviderMetadata, CompileTokenMetadata} from '../compile_metadata';\nimport {CompileReflector} from '../compile_reflector';\nimport {DepFlags, NodeFlags} from '../core';\nimport {Identifiers, createTokenForExternalReference} from '../identifiers';\nimport {LifecycleHooks} from '../lifecycle_reflector';\nimport * as o from '../output/output_ast';\nimport {convertValueToOutputAst} from '../output/value_util';\nimport {ProviderAst, ProviderAstType} from '../template_parser/template_ast';\nimport {OutputContext} from '../util';\n\nexport function providerDef(ctx: OutputContext, providerAst: ProviderAst): {\n  providerExpr: o.Expression,\n  flags: NodeFlags,\n  depsExpr: o.Expression,\n  tokenExpr: o.Expression\n} {\n  let flags = NodeFlags.None;\n  if (!providerAst.eager) {\n    flags |= NodeFlags.LazyProvider;\n  }\n  if (providerAst.providerType === ProviderAstType.PrivateService) {\n    flags |= NodeFlags.PrivateProvider;\n  }\n  if (providerAst.isModule) {\n    flags |= NodeFlags.TypeModuleProvider;\n  }\n  providerAst.lifecycleHooks.forEach((lifecycleHook) => {\n    // for regular providers, we only support ngOnDestroy\n    if (lifecycleHook === LifecycleHooks.OnDestroy ||\n        providerAst.providerType === ProviderAstType.Directive ||\n        providerAst.providerType === ProviderAstType.Component) {\n      flags |= lifecycleHookToNodeFlag(lifecycleHook);\n    }\n  });\n  const {providerExpr, flags: providerFlags, depsExpr} = providerAst.multiProvider ?\n      multiProviderDef(ctx, flags, providerAst.providers) :\n      singleProviderDef(ctx, flags, providerAst.providerType, providerAst.providers[0]);\n  return {\n    providerExpr,\n    flags: providerFlags, depsExpr,\n    tokenExpr: tokenExpr(ctx, providerAst.token),\n  };\n}\n\nfunction multiProviderDef(\n    ctx: OutputContext, flags: NodeFlags, providers: CompileProviderMetadata[]):\n    {providerExpr: o.Expression, flags: NodeFlags, depsExpr: o.Expression} {\n  const allDepDefs: o.Expression[] = [];\n  const allParams: o.FnParam[] = [];\n  const exprs = providers.map((provider, providerIndex) => {\n    let expr: o.Expression;\n    if (provider.useClass) {\n      const depExprs = convertDeps(providerIndex, provider.deps || provider.useClass.diDeps);\n      expr = ctx.importExpr(provider.useClass.reference).instantiate(depExprs);\n    } else if (provider.useFactory) {\n      const depExprs = convertDeps(providerIndex, provider.deps || provider.useFactory.diDeps);\n      expr = ctx.importExpr(provider.useFactory.reference).callFn(depExprs);\n    } else if (provider.useExisting) {\n      const depExprs = convertDeps(providerIndex, [{token: provider.useExisting}]);\n      expr = depExprs[0];\n    } else {\n      expr = convertValueToOutputAst(ctx, provider.useValue);\n    }\n    return expr;\n  });\n  const providerExpr =\n      o.fn(allParams, [new o.ReturnStatement(o.literalArr(exprs))], o.INFERRED_TYPE);\n  return {\n    providerExpr,\n    flags: flags | NodeFlags.TypeFactoryProvider,\n    depsExpr: o.literalArr(allDepDefs)\n  };\n\n  function convertDeps(providerIndex: number, deps: CompileDiDependencyMetadata[]) {\n    return deps.map((dep, depIndex) => {\n      const paramName = `p${providerIndex}_${depIndex}`;\n      allParams.push(new o.FnParam(paramName, o.DYNAMIC_TYPE));\n      allDepDefs.push(depDef(ctx, dep));\n      return o.variable(paramName);\n    });\n  }\n}\n\nfunction singleProviderDef(\n    ctx: OutputContext, flags: NodeFlags, providerType: ProviderAstType,\n    providerMeta: CompileProviderMetadata):\n    {providerExpr: o.Expression, flags: NodeFlags, depsExpr: o.Expression} {\n  let providerExpr: o.Expression;\n  let deps: CompileDiDependencyMetadata[];\n  if (providerType === ProviderAstType.Directive || providerType === ProviderAstType.Component) {\n    providerExpr = ctx.importExpr(providerMeta.useClass !.reference);\n    flags |= NodeFlags.TypeDirective;\n    deps = providerMeta.deps || providerMeta.useClass !.diDeps;\n  } else {\n    if (providerMeta.useClass) {\n      providerExpr = ctx.importExpr(providerMeta.useClass.reference);\n      flags |= NodeFlags.TypeClassProvider;\n      deps = providerMeta.deps || providerMeta.useClass.diDeps;\n    } else if (providerMeta.useFactory) {\n      providerExpr = ctx.importExpr(providerMeta.useFactory.reference);\n      flags |= NodeFlags.TypeFactoryProvider;\n      deps = providerMeta.deps || providerMeta.useFactory.diDeps;\n    } else if (providerMeta.useExisting) {\n      providerExpr = o.NULL_EXPR;\n      flags |= NodeFlags.TypeUseExistingProvider;\n      deps = [{token: providerMeta.useExisting}];\n    } else {\n      providerExpr = convertValueToOutputAst(ctx, providerMeta.useValue);\n      flags |= NodeFlags.TypeValueProvider;\n      deps = [];\n    }\n  }\n  const depsExpr = o.literalArr(deps.map(dep => depDef(ctx, dep)));\n  return {providerExpr, flags, depsExpr};\n}\n\nfunction tokenExpr(ctx: OutputContext, tokenMeta: CompileTokenMetadata): o.Expression {\n  return tokenMeta.identifier ? ctx.importExpr(tokenMeta.identifier.reference) :\n                                o.literal(tokenMeta.value);\n}\n\nexport function depDef(ctx: OutputContext, dep: CompileDiDependencyMetadata): o.Expression {\n  // Note: the following fields have already been normalized out by provider_analyzer:\n  // - isAttribute, isHost\n  const expr = dep.isValue ? convertValueToOutputAst(ctx, dep.value) : tokenExpr(ctx, dep.token !);\n  let flags = DepFlags.None;\n  if (dep.isSkipSelf) {\n    flags |= DepFlags.SkipSelf;\n  }\n  if (dep.isOptional) {\n    flags |= DepFlags.Optional;\n  }\n  if (dep.isSelf) {\n    flags |= DepFlags.Self;\n  }\n  if (dep.isValue) {\n    flags |= DepFlags.Value;\n  }\n  return flags === DepFlags.None ? expr : o.literalArr([o.literal(flags), expr]);\n}\n\nexport function lifecycleHookToNodeFlag(lifecycleHook: LifecycleHooks): NodeFlags {\n  let nodeFlag = NodeFlags.None;\n  switch (lifecycleHook) {\n    case LifecycleHooks.AfterContentChecked:\n      nodeFlag = NodeFlags.AfterContentChecked;\n      break;\n    case LifecycleHooks.AfterContentInit:\n      nodeFlag = NodeFlags.AfterContentInit;\n      break;\n    case LifecycleHooks.AfterViewChecked:\n      nodeFlag = NodeFlags.AfterViewChecked;\n      break;\n    case LifecycleHooks.AfterViewInit:\n      nodeFlag = NodeFlags.AfterViewInit;\n      break;\n    case LifecycleHooks.DoCheck:\n      nodeFlag = NodeFlags.DoCheck;\n      break;\n    case LifecycleHooks.OnChanges:\n      nodeFlag = NodeFlags.OnChanges;\n      break;\n    case LifecycleHooks.OnDestroy:\n      nodeFlag = NodeFlags.OnDestroy;\n      break;\n    case LifecycleHooks.OnInit:\n      nodeFlag = NodeFlags.OnInit;\n      break;\n  }\n  return nodeFlag;\n}\n\nexport function componentFactoryResolverProviderDef(\n    reflector: CompileReflector, ctx: OutputContext, flags: NodeFlags,\n    entryComponents: CompileEntryComponentMetadata[]): {\n  providerExpr: o.Expression,\n  flags: NodeFlags,\n  depsExpr: o.Expression,\n  tokenExpr: o.Expression\n} {\n  const entryComponentFactories =\n      entryComponents.map((entryComponent) => ctx.importExpr(entryComponent.componentFactory));\n  const token = createTokenForExternalReference(reflector, Identifiers.ComponentFactoryResolver);\n  const classMeta = {\n    diDeps: [\n      {isValue: true, value: o.literalArr(entryComponentFactories)},\n      {token: token, isSkipSelf: true, isOptional: true},\n      {token: createTokenForExternalReference(reflector, Identifiers.NgModuleRef)},\n    ],\n    lifecycleHooks: [],\n    reference: reflector.resolveExternalReference(Identifiers.CodegenComponentFactoryResolver)\n  };\n  const {providerExpr, flags: providerFlags, depsExpr} =\n      singleProviderDef(ctx, flags, ProviderAstType.PrivateService, {\n        token,\n        multi: false,\n        useClass: classMeta,\n      });\n  return {providerExpr, flags: providerFlags, depsExpr, tokenExpr: tokenExpr(ctx, token)};\n}\n"]}