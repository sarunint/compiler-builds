{"version":3,"file":"type_check_compiler.js","sourceRoot":"","sources":["../../../../../../packages/compiler/src/view_compiler/type_check_compiler.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {AotCompilerOptions} from '../aot/compiler_options';\nimport {StaticReflector} from '../aot/static_reflector';\nimport {StaticSymbol} from '../aot/static_symbol';\nimport {CompileDiDependencyMetadata, CompileDirectiveMetadata, CompilePipeSummary} from '../compile_metadata';\nimport {BindingForm, BuiltinConverter, EventHandlerVars, LocalResolver, convertActionBinding, convertPropertyBinding, convertPropertyBindingBuiltins} from '../compiler_util/expression_converter';\nimport {AST, ASTWithSource, Interpolation} from '../expression_parser/ast';\nimport {Identifiers} from '../identifiers';\nimport * as o from '../output/output_ast';\nimport {convertValueToOutputAst} from '../output/value_util';\nimport {ParseSourceSpan} from '../parse_util';\nimport {AttrAst, BoundDirectivePropertyAst, BoundElementPropertyAst, BoundEventAst, BoundTextAst, DirectiveAst, ElementAst, EmbeddedTemplateAst, NgContentAst, PropertyBindingType, ProviderAst, ProviderAstType, QueryMatch, ReferenceAst, TemplateAst, TemplateAstVisitor, TextAst, VariableAst, templateVisitAll} from '../template_parser/template_ast';\nimport {OutputContext} from '../util';\n\n\n/**\n * Generates code that is used to type check templates.\n */\nexport class TypeCheckCompiler {\n  constructor(private options: AotCompilerOptions, private reflector: StaticReflector) {}\n\n  /**\n   * Important notes:\n   * - This must not produce new `import` statements, but only refer to types outside\n   *   of the file via the variables provided via externalReferenceVars.\n   *   This allows Typescript to reuse the old program's structure as no imports have changed.\n   * - This must not produce any exports, as this would pollute the .d.ts file\n   *   and also violate the point above.\n   */\n  compileComponent(\n      componentId: string, component: CompileDirectiveMetadata, template: TemplateAst[],\n      usedPipes: CompilePipeSummary[], externalReferenceVars: Map<StaticSymbol, string>,\n      ctx: OutputContext): o.Statement[] {\n    const pipes = new Map<string, StaticSymbol>();\n    usedPipes.forEach(p => pipes.set(p.name, p.type.reference));\n    let embeddedViewCount = 0;\n    const viewBuilderFactory =\n        (parent: ViewBuilder | null, guards: GuardExpression[]): ViewBuilder => {\n          const embeddedViewIndex = embeddedViewCount++;\n          return new ViewBuilder(\n              this.options, this.reflector, externalReferenceVars, parent, component.type.reference,\n              component.isHost, embeddedViewIndex, pipes, guards, ctx, viewBuilderFactory);\n        };\n\n    const visitor = viewBuilderFactory(null, []);\n    visitor.visitAll([], template);\n\n    return visitor.build(componentId);\n  }\n}\n\ninterface GuardExpression {\n  guard: StaticSymbol;\n  useIf: boolean;\n  expression: Expression;\n}\n\ninterface ViewBuilderFactory {\n  (parent: ViewBuilder, guards: GuardExpression[]): ViewBuilder;\n}\n\n// Note: This is used as key in Map and should therefore be\n// unique per value.\ntype OutputVarType = o.BuiltinTypeName | StaticSymbol;\n\ninterface Expression {\n  context: OutputVarType;\n  sourceSpan: ParseSourceSpan;\n  value: AST;\n}\n\nconst DYNAMIC_VAR_NAME = '_any';\n\nclass TypeCheckLocalResolver implements LocalResolver {\n  getLocal(name: string): o.Expression|null {\n    if (name === EventHandlerVars.event.name) {\n      // References to the event should not be type-checked.\n      // TODO(chuckj): determine a better type for the event.\n      return o.variable(DYNAMIC_VAR_NAME);\n    }\n    return null;\n  }\n}\n\nconst defaultResolver = new TypeCheckLocalResolver();\n\nclass ViewBuilder implements TemplateAstVisitor, LocalResolver {\n  private refOutputVars = new Map<string, OutputVarType>();\n  private variables: VariableAst[] = [];\n  private children: ViewBuilder[] = [];\n  private updates: Expression[] = [];\n  private actions: Expression[] = [];\n\n  constructor(\n      private options: AotCompilerOptions, private reflector: StaticReflector,\n      private externalReferenceVars: Map<StaticSymbol, string>, private parent: ViewBuilder|null,\n      private component: StaticSymbol, private isHostComponent: boolean,\n      private embeddedViewIndex: number, private pipes: Map<string, StaticSymbol>,\n      private guards: GuardExpression[], private ctx: OutputContext,\n      private viewBuilderFactory: ViewBuilderFactory) {}\n\n  private getOutputVar(type: o.BuiltinTypeName|StaticSymbol): string {\n    let varName: string|undefined;\n    if (type === this.component && this.isHostComponent) {\n      varName = DYNAMIC_VAR_NAME;\n    } else if (type instanceof StaticSymbol) {\n      varName = this.externalReferenceVars.get(type);\n    } else {\n      varName = DYNAMIC_VAR_NAME;\n    }\n    if (!varName) {\n      throw new Error(\n          `Illegal State: referring to a type without a variable ${JSON.stringify(type)}`);\n    }\n    return varName;\n  }\n\n  private getTypeGuardExpressions(ast: EmbeddedTemplateAst): GuardExpression[] {\n    const result = [...this.guards];\n    for (let directive of ast.directives) {\n      for (let input of directive.inputs) {\n        const guard = directive.directive.guards[input.directiveName];\n        if (guard) {\n          const useIf = guard === 'UseIf';\n          result.push({\n            guard,\n            useIf,\n            expression: {context: this.component, value: input.value} as Expression\n          });\n        }\n      }\n    }\n    return result;\n  }\n\n  visitAll(variables: VariableAst[], astNodes: TemplateAst[]) {\n    this.variables = variables;\n    templateVisitAll(this, astNodes);\n  }\n\n  build(componentId: string, targetStatements: o.Statement[] = []): o.Statement[] {\n    this.children.forEach((child) => child.build(componentId, targetStatements));\n    let viewStmts: o.Statement[] =\n        [o.variable(DYNAMIC_VAR_NAME).set(o.NULL_EXPR).toDeclStmt(o.DYNAMIC_TYPE)];\n    let bindingCount = 0;\n    this.updates.forEach((expression) => {\n      const {sourceSpan, context, value} = this.preprocessUpdateExpression(expression);\n      const bindingId = `${bindingCount++}`;\n      const nameResolver = context === this.component ? this : defaultResolver;\n      const {stmts, currValExpr} = convertPropertyBinding(\n          nameResolver, o.variable(this.getOutputVar(context)), value, bindingId,\n          BindingForm.General);\n      stmts.push(new o.ExpressionStatement(currValExpr));\n      viewStmts.push(...stmts.map(\n          (stmt: o.Statement) => o.applySourceSpanToStatementIfNeeded(stmt, sourceSpan)));\n    });\n\n    this.actions.forEach(({sourceSpan, context, value}) => {\n      const bindingId = `${bindingCount++}`;\n      const nameResolver = context === this.component ? this : defaultResolver;\n      const {stmts} = convertActionBinding(\n          nameResolver, o.variable(this.getOutputVar(context)), value, bindingId);\n      viewStmts.push(...stmts.map(\n          (stmt: o.Statement) => o.applySourceSpanToStatementIfNeeded(stmt, sourceSpan)));\n    });\n\n    if (this.guards.length) {\n      let guardExpression: o.Expression|undefined = undefined;\n      for (const guard of this.guards) {\n        const {context, value} = this.preprocessUpdateExpression(guard.expression);\n        const bindingId = `${bindingCount++}`;\n        const nameResolver = context === this.component ? this : defaultResolver;\n        // We only support support simple expressions and ignore others as they\n        // are unlikely to affect type narrowing.\n        const {stmts, currValExpr} = convertPropertyBinding(\n            nameResolver, o.variable(this.getOutputVar(context)), value, bindingId,\n            BindingForm.TrySimple);\n        if (stmts.length == 0) {\n          const guardClause =\n              guard.useIf ? currValExpr : this.ctx.importExpr(guard.guard).callFn([currValExpr]);\n          guardExpression = guardExpression ? guardExpression.and(guardClause) : guardClause;\n        }\n      }\n      if (guardExpression) {\n        viewStmts = [new o.IfStmt(guardExpression, viewStmts)];\n      }\n    }\n\n    const viewName = `_View_${componentId}_${this.embeddedViewIndex}`;\n    const viewFactory = new o.DeclareFunctionStmt(viewName, [], viewStmts);\n    targetStatements.push(viewFactory);\n    return targetStatements;\n  }\n\n  visitBoundText(ast: BoundTextAst, context: any): any {\n    const astWithSource = <ASTWithSource>ast.value;\n    const inter = <Interpolation>astWithSource.ast;\n\n    inter.expressions.forEach(\n        (expr) =>\n            this.updates.push({context: this.component, value: expr, sourceSpan: ast.sourceSpan}));\n  }\n\n  visitEmbeddedTemplate(ast: EmbeddedTemplateAst, context: any): any {\n    this.visitElementOrTemplate(ast);\n    // Note: The old view compiler used to use an `any` type\n    // for the context in any embedded view.\n    // We keep this behaivor behind a flag for now.\n    if (this.options.fullTemplateTypeCheck) {\n      // Find any applicable type guards. For example, NgIf has a type guard on ngIf\n      // (see NgIf.ngIfTypeGuard) that can be used to indicate that a template is only\n      // stamped out if ngIf is truthy so any bindings in the template can assume that,\n      // if a nullable type is used for ngIf, that expression is not null or undefined.\n      const guards = this.getTypeGuardExpressions(ast);\n      const childVisitor = this.viewBuilderFactory(this, guards);\n      this.children.push(childVisitor);\n      childVisitor.visitAll(ast.variables, ast.children);\n    }\n  }\n\n  visitElement(ast: ElementAst, context: any): any {\n    this.visitElementOrTemplate(ast);\n\n    let inputDefs: o.Expression[] = [];\n    let updateRendererExpressions: Expression[] = [];\n    let outputDefs: o.Expression[] = [];\n    ast.inputs.forEach((inputAst) => {\n      this.updates.push(\n          {context: this.component, value: inputAst.value, sourceSpan: inputAst.sourceSpan});\n    });\n\n    templateVisitAll(this, ast.children);\n  }\n\n  private visitElementOrTemplate(ast: {\n    outputs: BoundEventAst[],\n    directives: DirectiveAst[],\n    references: ReferenceAst[],\n  }) {\n    ast.directives.forEach((dirAst) => { this.visitDirective(dirAst); });\n\n    ast.references.forEach((ref) => {\n      let outputVarType: OutputVarType = null !;\n      // Note: The old view compiler used to use an `any` type\n      // for directives exposed via `exportAs`.\n      // We keep this behaivor behind a flag for now.\n      if (ref.value && ref.value.identifier && this.options.fullTemplateTypeCheck) {\n        outputVarType = ref.value.identifier.reference;\n      } else {\n        outputVarType = o.BuiltinTypeName.Dynamic;\n      }\n      this.refOutputVars.set(ref.name, outputVarType);\n    });\n    ast.outputs.forEach((outputAst) => {\n      this.actions.push(\n          {context: this.component, value: outputAst.handler, sourceSpan: outputAst.sourceSpan});\n    });\n  }\n\n  visitDirective(dirAst: DirectiveAst) {\n    const dirType = dirAst.directive.type.reference;\n    dirAst.inputs.forEach(\n        (input) => this.updates.push(\n            {context: this.component, value: input.value, sourceSpan: input.sourceSpan}));\n    // Note: The old view compiler used to use an `any` type\n    // for expressions in host properties / events.\n    // We keep this behaivor behind a flag for now.\n    if (this.options.fullTemplateTypeCheck) {\n      dirAst.hostProperties.forEach(\n          (inputAst) => this.updates.push(\n              {context: dirType, value: inputAst.value, sourceSpan: inputAst.sourceSpan}));\n      dirAst.hostEvents.forEach((hostEventAst) => this.actions.push({\n        context: dirType,\n        value: hostEventAst.handler,\n        sourceSpan: hostEventAst.sourceSpan\n      }));\n    }\n  }\n\n  getLocal(name: string): o.Expression|null {\n    if (name == EventHandlerVars.event.name) {\n      return o.variable(this.getOutputVar(o.BuiltinTypeName.Dynamic));\n    }\n    for (let currBuilder: ViewBuilder|null = this; currBuilder; currBuilder = currBuilder.parent) {\n      let outputVarType: OutputVarType|undefined;\n      // check references\n      outputVarType = currBuilder.refOutputVars.get(name);\n      if (outputVarType == null) {\n        // check variables\n        const varAst = currBuilder.variables.find((varAst) => varAst.name === name);\n        if (varAst) {\n          outputVarType = o.BuiltinTypeName.Dynamic;\n        }\n      }\n      if (outputVarType != null) {\n        return o.variable(this.getOutputVar(outputVarType));\n      }\n    }\n    return null;\n  }\n\n  private pipeOutputVar(name: string): string {\n    const pipe = this.pipes.get(name);\n    if (!pipe) {\n      throw new Error(\n          `Illegal State: Could not find pipe ${name} in template of ${this.component}`);\n    }\n    return this.getOutputVar(pipe);\n  }\n\n  private preprocessUpdateExpression(expression: Expression): Expression {\n    return {\n      sourceSpan: expression.sourceSpan,\n      context: expression.context,\n      value: convertPropertyBindingBuiltins(\n          {\n            createLiteralArrayConverter: (argCount: number) => (args: o.Expression[]) => {\n              const arr = o.literalArr(args);\n              // Note: The old view compiler used to use an `any` type\n              // for arrays.\n              return this.options.fullTemplateTypeCheck ? arr : arr.cast(o.DYNAMIC_TYPE);\n            },\n            createLiteralMapConverter:\n                (keys: {key: string, quoted: boolean}[]) => (values: o.Expression[]) => {\n                  const entries = keys.map((k, i) => ({\n                                             key: k.key,\n                                             value: values[i],\n                                             quoted: k.quoted,\n                                           }));\n                  const map = o.literalMap(entries);\n                  // Note: The old view compiler used to use an `any` type\n                  // for maps.\n                  return this.options.fullTemplateTypeCheck ? map : map.cast(o.DYNAMIC_TYPE);\n                },\n            createPipeConverter: (name: string, argCount: number) => (args: o.Expression[]) => {\n              // Note: The old view compiler used to use an `any` type\n              // for pipes.\n              const pipeExpr = this.options.fullTemplateTypeCheck ?\n                  o.variable(this.pipeOutputVar(name)) :\n                  o.variable(this.getOutputVar(o.BuiltinTypeName.Dynamic));\n              return pipeExpr.callMethod('transform', args);\n            },\n          },\n          expression.value)\n    };\n  }\n\n  visitNgContent(ast: NgContentAst, context: any): any {}\n  visitText(ast: TextAst, context: any): any {}\n  visitDirectiveProperty(ast: BoundDirectivePropertyAst, context: any): any {}\n  visitReference(ast: ReferenceAst, context: any): any {}\n  visitVariable(ast: VariableAst, context: any): any {}\n  visitEvent(ast: BoundEventAst, context: any): any {}\n  visitElementProperty(ast: BoundElementPropertyAst, context: any): any {}\n  visitAttr(ast: AttrAst, context: any): any {}\n}\n"]}