{"version":3,"file":"constant_pool.js","sourceRoot":"","sources":["../../../../../packages/compiler/src/constant_pool.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as o from './output/output_ast';\nimport {I18nMeta, parseI18nMeta} from './render3/view/i18n';\nimport {OutputContext, error} from './util';\n\nconst CONSTANT_PREFIX = '_c';\n\n// Closure variables holding messages must be named `MSG_[A-Z0-9]+`\nconst TRANSLATION_PREFIX = 'MSG_';\n\nexport const enum DefinitionKind {Injector, Directive, Component, Pipe}\n\n/**\n * Closure uses `goog.getMsg(message)` to lookup translations\n */\nconst GOOG_GET_MSG = 'goog.getMsg';\n\n/**\n * Context to use when producing a key.\n *\n * This ensures we see the constant not the reference variable when producing\n * a key.\n */\nconst KEY_CONTEXT = {};\n\n/**\n * A node that is a place-holder that allows the node to be replaced when the actual\n * node is known.\n *\n * This allows the constant pool to change an expression from a direct reference to\n * a constant to a shared constant. It returns a fix-up node that is later allowed to\n * change the referenced expression.\n */\nclass FixupExpression extends o.Expression {\n  private original: o.Expression;\n\n  // TODO(issue/24571): remove '!'.\n  shared !: boolean;\n\n  constructor(public resolved: o.Expression) {\n    super(resolved.type);\n    this.original = resolved;\n  }\n\n  visitExpression(visitor: o.ExpressionVisitor, context: any): any {\n    if (context === KEY_CONTEXT) {\n      // When producing a key we want to traverse the constant not the\n      // variable used to refer to it.\n      return this.original.visitExpression(visitor, context);\n    } else {\n      return this.resolved.visitExpression(visitor, context);\n    }\n  }\n\n  isEquivalent(e: o.Expression): boolean {\n    return e instanceof FixupExpression && this.resolved.isEquivalent(e.resolved);\n  }\n\n  isConstant() { return true; }\n\n  fixup(expression: o.Expression) {\n    this.resolved = expression;\n    this.shared = true;\n  }\n}\n\n/**\n * A constant pool allows a code emitter to share constant in an output context.\n *\n * The constant pool also supports sharing access to ivy definitions references.\n */\nexport class ConstantPool {\n  statements: o.Statement[] = [];\n  private translations = new Map<string, o.Expression>();\n  private deferredTranslations = new Map<o.ReadVarExpr, number>();\n  private literals = new Map<string, FixupExpression>();\n  private literalFactories = new Map<string, o.Expression>();\n  private injectorDefinitions = new Map<any, FixupExpression>();\n  private directiveDefinitions = new Map<any, FixupExpression>();\n  private componentDefinitions = new Map<any, FixupExpression>();\n  private pipeDefinitions = new Map<any, FixupExpression>();\n\n  private nextNameIndex = 0;\n\n  getConstLiteral(literal: o.Expression, forceShared?: boolean): o.Expression {\n    if (literal instanceof o.LiteralExpr || literal instanceof FixupExpression) {\n      // Do no put simple literals into the constant pool or try to produce a constant for a\n      // reference to a constant.\n      return literal;\n    }\n    const key = this.keyOf(literal);\n    let fixup = this.literals.get(key);\n    let newValue = false;\n    if (!fixup) {\n      fixup = new FixupExpression(literal);\n      this.literals.set(key, fixup);\n      newValue = true;\n    }\n\n    if ((!newValue && !fixup.shared) || (newValue && forceShared)) {\n      // Replace the expression with a variable\n      const name = this.freshName();\n      this.statements.push(\n          o.variable(name).set(literal).toDeclStmt(o.INFERRED_TYPE, [o.StmtModifier.Final]));\n      fixup.fixup(o.variable(name));\n    }\n\n    return fixup;\n  }\n\n  getDeferredTranslationConst(suffix: string): o.ReadVarExpr {\n    const index = this.statements.push(new o.ExpressionStatement(o.NULL_EXPR)) - 1;\n    const variable = o.variable(this.freshTranslationName(suffix));\n    this.deferredTranslations.set(variable, index);\n    return variable;\n  }\n\n  setDeferredTranslationConst(variable: o.ReadVarExpr, message: string): void {\n    const index = this.deferredTranslations.get(variable) !;\n    this.statements[index] = this.getTranslationDeclStmt(variable, message);\n  }\n\n  getTranslationDeclStmt(variable: o.ReadVarExpr, message: string): o.DeclareVarStmt {\n    const fnCall = o.variable(GOOG_GET_MSG).callFn([o.literal(message)]);\n    return variable.set(fnCall).toDeclStmt(o.INFERRED_TYPE, [o.StmtModifier.Final]);\n  }\n\n  appendTranslationMeta(meta: string|I18nMeta) {\n    const parsedMeta = typeof meta === 'string' ? parseI18nMeta(meta) : meta;\n    const docStmt = i18nMetaToDocStmt(parsedMeta);\n    if (docStmt) {\n      this.statements.push(docStmt);\n    }\n  }\n\n  // Generates closure specific code for translation.\n  //\n  // ```\n  // /**\n  //  * @desc description?\n  //  * @meaning meaning?\n  //  */\n  // const MSG_XYZ = goog.getMsg('message');\n  // ```\n  getTranslation(message: string, meta: string, suffix: string): o.Expression {\n    const parsedMeta = parseI18nMeta(meta);\n\n    // The identity of an i18n message depends on the message and its meaning\n    const key = parsedMeta.meaning ? `${message}\\u0000\\u0000${parsedMeta.meaning}` : message;\n\n    const exp = this.translations.get(key);\n\n    if (exp) {\n      return exp;\n    }\n\n    const variable = o.variable(this.freshTranslationName(suffix));\n    this.appendTranslationMeta(parsedMeta);\n    this.statements.push(this.getTranslationDeclStmt(variable, message));\n\n    this.translations.set(key, variable);\n    return variable;\n  }\n\n  getDefinition(type: any, kind: DefinitionKind, ctx: OutputContext, forceShared: boolean = false):\n      o.Expression {\n    const definitions = this.definitionsOf(kind);\n    let fixup = definitions.get(type);\n    let newValue = false;\n    if (!fixup) {\n      const property = this.propertyNameOf(kind);\n      fixup = new FixupExpression(ctx.importExpr(type).prop(property));\n      definitions.set(type, fixup);\n      newValue = true;\n    }\n\n    if ((!newValue && !fixup.shared) || (newValue && forceShared)) {\n      const name = this.freshName();\n      this.statements.push(\n          o.variable(name).set(fixup.resolved).toDeclStmt(o.INFERRED_TYPE, [o.StmtModifier.Final]));\n      fixup.fixup(o.variable(name));\n    }\n    return fixup;\n  }\n\n  getLiteralFactory(literal: o.LiteralArrayExpr|o.LiteralMapExpr):\n      {literalFactory: o.Expression, literalFactoryArguments: o.Expression[]} {\n    // Create a pure function that builds an array of a mix of constant  and variable expressions\n    if (literal instanceof o.LiteralArrayExpr) {\n      const argumentsForKey = literal.entries.map(e => e.isConstant() ? e : o.literal(null));\n      const key = this.keyOf(o.literalArr(argumentsForKey));\n      return this._getLiteralFactory(key, literal.entries, entries => o.literalArr(entries));\n    } else {\n      const expressionForKey = o.literalMap(\n          literal.entries.map(e => ({\n                                key: e.key,\n                                value: e.value.isConstant() ? e.value : o.literal(null),\n                                quoted: e.quoted\n                              })));\n      const key = this.keyOf(expressionForKey);\n      return this._getLiteralFactory(\n          key, literal.entries.map(e => e.value),\n          entries => o.literalMap(entries.map((value, index) => ({\n                                                key: literal.entries[index].key,\n                                                value,\n                                                quoted: literal.entries[index].quoted\n                                              }))));\n    }\n  }\n\n  private _getLiteralFactory(\n      key: string, values: o.Expression[], resultMap: (parameters: o.Expression[]) => o.Expression):\n      {literalFactory: o.Expression, literalFactoryArguments: o.Expression[]} {\n    let literalFactory = this.literalFactories.get(key);\n    const literalFactoryArguments = values.filter((e => !e.isConstant()));\n    if (!literalFactory) {\n      const resultExpressions = values.map(\n          (e, index) => e.isConstant() ? this.getConstLiteral(e, true) : o.variable(`a${index}`));\n      const parameters =\n          resultExpressions.filter(isVariable).map(e => new o.FnParam(e.name !, o.DYNAMIC_TYPE));\n      const pureFunctionDeclaration =\n          o.fn(parameters, [new o.ReturnStatement(resultMap(resultExpressions))], o.INFERRED_TYPE);\n      const name = this.freshName();\n      this.statements.push(\n          o.variable(name).set(pureFunctionDeclaration).toDeclStmt(o.INFERRED_TYPE, [\n            o.StmtModifier.Final\n          ]));\n      literalFactory = o.variable(name);\n      this.literalFactories.set(key, literalFactory);\n    }\n    return {literalFactory, literalFactoryArguments};\n  }\n\n  /**\n   * Produce a unique name.\n   *\n   * The name might be unique among different prefixes if any of the prefixes end in\n   * a digit so the prefix should be a constant string (not based on user input) and\n   * must not end in a digit.\n   */\n  uniqueName(prefix: string): string { return `${prefix}${this.nextNameIndex++}`; }\n\n  private definitionsOf(kind: DefinitionKind): Map<any, FixupExpression> {\n    switch (kind) {\n      case DefinitionKind.Component:\n        return this.componentDefinitions;\n      case DefinitionKind.Directive:\n        return this.directiveDefinitions;\n      case DefinitionKind.Injector:\n        return this.injectorDefinitions;\n      case DefinitionKind.Pipe:\n        return this.pipeDefinitions;\n    }\n    error(`Unknown definition kind ${kind}`);\n    return this.componentDefinitions;\n  }\n\n  public propertyNameOf(kind: DefinitionKind): string {\n    switch (kind) {\n      case DefinitionKind.Component:\n        return 'ngComponentDef';\n      case DefinitionKind.Directive:\n        return 'ngDirectiveDef';\n      case DefinitionKind.Injector:\n        return 'ngInjectorDef';\n      case DefinitionKind.Pipe:\n        return 'ngPipeDef';\n    }\n    error(`Unknown definition kind ${kind}`);\n    return '<unknown>';\n  }\n\n  private freshName(): string { return this.uniqueName(CONSTANT_PREFIX); }\n\n  private freshTranslationName(suffix: string): string {\n    return this.uniqueName(TRANSLATION_PREFIX + suffix).toUpperCase();\n  }\n\n  private keyOf(expression: o.Expression) {\n    return expression.visitExpression(new KeyVisitor(), KEY_CONTEXT);\n  }\n}\n\n/**\n * Visitor used to determine if 2 expressions are equivalent and can be shared in the\n * `ConstantPool`.\n *\n * When the id (string) generated by the visitor is equal, expressions are considered equivalent.\n */\nclass KeyVisitor implements o.ExpressionVisitor {\n  visitLiteralExpr(ast: o.LiteralExpr): string {\n    return `${typeof ast.value === 'string' ? '\"' + ast.value + '\"' : ast.value}`;\n  }\n\n  visitLiteralArrayExpr(ast: o.LiteralArrayExpr, context: object): string {\n    return `[${ast.entries.map(entry => entry.visitExpression(this, context)).join(',')}]`;\n  }\n\n  visitLiteralMapExpr(ast: o.LiteralMapExpr, context: object): string {\n    const mapKey = (entry: o.LiteralMapEntry) => {\n      const quote = entry.quoted ? '\"' : '';\n      return `${quote}${entry.key}${quote}`;\n    };\n    const mapEntry = (entry: o.LiteralMapEntry) =>\n        `${mapKey(entry)}:${entry.value.visitExpression(this, context)}`;\n    return `{${ast.entries.map(mapEntry).join(',')}`;\n  }\n\n  visitExternalExpr(ast: o.ExternalExpr): string {\n    return ast.value.moduleName ? `EX:${ast.value.moduleName}:${ast.value.name}` :\n                                  `EX:${ast.value.runtime.name}`;\n  }\n\n  visitReadVarExpr(node: o.ReadVarExpr) { return `VAR:${node.name}`; }\n\n  visitTypeofExpr(node: o.TypeofExpr, context: any): string {\n    return `TYPEOF:${node.expr.visitExpression(this, context)}`;\n  }\n\n  visitWrappedNodeExpr = invalid;\n  visitWriteVarExpr = invalid;\n  visitWriteKeyExpr = invalid;\n  visitWritePropExpr = invalid;\n  visitInvokeMethodExpr = invalid;\n  visitInvokeFunctionExpr = invalid;\n  visitInstantiateExpr = invalid;\n  visitConditionalExpr = invalid;\n  visitNotExpr = invalid;\n  visitAssertNotNullExpr = invalid;\n  visitCastExpr = invalid;\n  visitFunctionExpr = invalid;\n  visitBinaryOperatorExpr = invalid;\n  visitReadPropExpr = invalid;\n  visitReadKeyExpr = invalid;\n  visitCommaExpr = invalid;\n}\n\nfunction invalid<T>(arg: o.Expression | o.Statement): never {\n  throw new Error(\n      `Invalid state: Visitor ${this.constructor.name} doesn't handle ${arg.constructor.name}`);\n}\n\nfunction isVariable(e: o.Expression): e is o.ReadVarExpr {\n  return e instanceof o.ReadVarExpr;\n}\n\n// Converts i18n meta informations for a message (id, description, meaning)\n// to a JsDoc statement formatted as expected by the Closure compiler.\nfunction i18nMetaToDocStmt(meta: I18nMeta): o.JSDocCommentStmt|null {\n  const tags: o.JSDocTag[] = [];\n\n  if (meta.id || meta.description) {\n    const text = meta.id ? `[BACKUP_MESSAGE_ID:${meta.id}] ${meta.description}` : meta.description;\n    tags.push({tagName: o.JSDocTagName.Desc, text: text !.trim()});\n  }\n\n  if (meta.meaning) {\n    tags.push({tagName: o.JSDocTagName.Meaning, text: meta.meaning});\n  }\n\n  return tags.length == 0 ? null : new o.JSDocCommentStmt(tags);\n}\n"]}