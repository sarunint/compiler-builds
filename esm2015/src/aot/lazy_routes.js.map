{"version":3,"file":"lazy_routes.js","sourceRoot":"","sources":["../../../../../packages/compiler/src/aot/lazy_routes.ts"],"names":[],"mappings":"AAAA;;;;;;GAMG;AAEH,OAAO,EAA0B,cAAc,EAAC,MAAM,qBAAqB,CAAC;AAc5E,MAAM,UAAU,cAAc,CAC1B,UAAmC,EAAE,SAA0B;IACjE,MAAM,aAAa,GAAgB,EAAE,CAAC;IACtC,KAAK,MAAM,EAAC,QAAQ,EAAE,MAAM,EAAC,IAAI,UAAU,CAAC,gBAAgB,CAAC,SAAS,EAAE;QACtE,IAAI,cAAc,CAAC,QAAQ,CAAC,KAAK,CAAC,KAAK,SAAS,CAAC,MAAM,EAAE;YACvD,MAAM,YAAY,GAAG,oBAAoB,CAAC,QAAQ,CAAC,QAAQ,CAAC,CAAC;YAC7D,KAAK,MAAM,KAAK,IAAI,YAAY,EAAE;gBAChC,aAAa,CAAC,IAAI,CAAC,cAAc,CAAC,KAAK,EAAE,SAAS,EAAE,MAAM,CAAC,SAAS,CAAC,CAAC,CAAC;aACxE;SACF;KACF;IACD,OAAO,aAAa,CAAC;AACvB,CAAC;AAED,SAAS,oBAAoB,CAAC,MAAgC,EAAE,SAAmB,EAAE;IACnF,IAAI,OAAO,MAAM,KAAK,QAAQ,EAAE;QAC9B,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;KACrB;SAAM,IAAI,KAAK,CAAC,OAAO,CAAC,MAAM,CAAC,EAAE;QAChC,KAAK,MAAM,KAAK,IAAI,MAAM,EAAE;YAC1B,oBAAoB,CAAC,KAAK,EAAE,MAAM,CAAC,CAAC;SACrC;KACF;SAAM,IAAI,MAAM,CAAC,YAAY,EAAE;QAC9B,oBAAoB,CAAC,MAAM,CAAC,YAAY,EAAE,MAAM,CAAC,CAAC;KACnD;SAAM,IAAI,MAAM,CAAC,QAAQ,EAAE;QAC1B,oBAAoB,CAAC,MAAM,CAAC,QAAQ,EAAE,MAAM,CAAC,CAAC;KAC/C;IACD,OAAO,MAAM,CAAC;AAChB,CAAC;AAED,MAAM,UAAU,cAAc,CAC1B,KAAa,EAAE,SAA0B,EAAE,MAAqB;IAClE,MAAM,CAAC,SAAS,EAAE,SAAS,CAAC,GAAG,KAAK,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;IAChD,MAAM,gBAAgB,GAAG,SAAS,CAAC,wBAAwB,CACvD;QACE,UAAU,EAAE,SAAS;QACrB,IAAI,EAAE,SAAS;KAChB,EACD,MAAM,CAAC,CAAC,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC;IAC1C,OAAO,EAAC,KAAK,EAAE,KAAK,EAAE,MAAM,EAAE,MAAM,IAAI,gBAAgB,EAAE,gBAAgB,EAAC,CAAC;AAC9E,CAAC","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {CompileNgModuleMetadata, tokenReference} from '../compile_metadata';\nimport {Route} from '../core';\nimport {CompileMetadataResolver} from '../metadata_resolver';\n\nimport {AotCompilerHost} from './compiler_host';\nimport {StaticReflector} from './static_reflector';\nimport {StaticSymbol} from './static_symbol';\n\nexport interface LazyRoute {\n  module: StaticSymbol;\n  route: string;\n  referencedModule: StaticSymbol;\n}\n\nexport function listLazyRoutes(\n    moduleMeta: CompileNgModuleMetadata, reflector: StaticReflector): LazyRoute[] {\n  const allLazyRoutes: LazyRoute[] = [];\n  for (const {provider, module} of moduleMeta.transitiveModule.providers) {\n    if (tokenReference(provider.token) === reflector.ROUTES) {\n      const loadChildren = _collectLoadChildren(provider.useValue);\n      for (const route of loadChildren) {\n        allLazyRoutes.push(parseLazyRoute(route, reflector, module.reference));\n      }\n    }\n  }\n  return allLazyRoutes;\n}\n\nfunction _collectLoadChildren(routes: string | Route | Route[], target: string[] = []): string[] {\n  if (typeof routes === 'string') {\n    target.push(routes);\n  } else if (Array.isArray(routes)) {\n    for (const route of routes) {\n      _collectLoadChildren(route, target);\n    }\n  } else if (routes.loadChildren) {\n    _collectLoadChildren(routes.loadChildren, target);\n  } else if (routes.children) {\n    _collectLoadChildren(routes.children, target);\n  }\n  return target;\n}\n\nexport function parseLazyRoute(\n    route: string, reflector: StaticReflector, module?: StaticSymbol): LazyRoute {\n  const [routePath, routeName] = route.split('#');\n  const referencedModule = reflector.resolveExternalReference(\n      {\n        moduleName: routePath,\n        name: routeName,\n      },\n      module ? module.filePath : undefined);\n  return {route: route, module: module || referencedModule, referencedModule};\n}\n"]}