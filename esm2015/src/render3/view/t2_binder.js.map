{"version":3,"file":"t2_binder.js","sourceRoot":"","sources":["../../../../../../packages/compiler/src/render3/view/t2_binder.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {AST, ImplicitReceiver, MethodCall, PropertyRead, PropertyWrite, RecursiveAstVisitor, SafeMethodCall, SafePropertyRead} from '../../expression_parser/ast';\nimport {CssSelector, SelectorMatcher} from '../../selector';\nimport {BoundAttribute, BoundEvent, BoundText, Content, Element, Node, Reference, Template, Text, TextAttribute, Variable, Visitor} from '../r3_ast';\n\nimport {BoundTarget, DirectiveMeta, Target, TargetBinder} from './t2_api';\nimport {getAttrsForDirectiveMatching} from './util';\n\n/**\n * Processes `Target`s with a given set of directives and performs a binding operation, which\n * returns an object similar to TypeScript's `ts.TypeChecker` that contains knowledge about the\n * target.\n */\nexport class R3TargetBinder<DirectiveT extends DirectiveMeta> implements TargetBinder<DirectiveT> {\n  constructor(private directiveMatcher: SelectorMatcher<DirectiveT>) {}\n\n  /**\n   * Perform a binding operation on the given `Target` and return a `BoundTarget` which contains\n   * metadata about the types referenced in the template.\n   */\n  bind(target: Target): BoundTarget<DirectiveT> {\n    if (!target.template) {\n      // TODO(alxhub): handle targets which contain things like HostBindings, etc.\n      throw new Error('Binding without a template not yet supported');\n    }\n\n    // First, parse the template into a `Scope` structure. This operation captures the syntactic\n    // scopes in the template and makes them available for later use.\n    const scope = Scope.apply(target.template);\n\n    // Next, perform directive matching on the template using the `DirectiveBinder`. This returns:\n    //   - directives: Map of nodes (elements & ng-templates) to the directives on them.\n    //   - bindings: Map of inputs, outputs, and attributes to the directive/element that claims\n    //     them. TODO(alxhub): handle multiple directives claiming an input/output/etc.\n    //   - references: Map of #references to their targets.\n    const {directives, bindings, references} =\n        DirectiveBinder.apply(target.template, this.directiveMatcher);\n    // Finally, run the TemplateBinder to bind references, variables, and other entities within the\n    // template. This extracts all the metadata that doesn't depend on directive matching.\n    const {expressions, symbols, nestingLevel} = TemplateBinder.apply(target.template, scope);\n    return new R3BoundTarget(\n        target, directives, bindings, references, expressions, symbols, nestingLevel);\n  }\n}\n\n/**\n * Represents a binding scope within a template.\n *\n * Any variables, references, or other named entities declared within the template will\n * be captured and available by name in `namedEntities`. Additionally, child templates will\n * be analyzed and have their child `Scope`s available in `childScopes`.\n */\nclass Scope implements Visitor {\n  /**\n   * Named members of the `Scope`, such as `Reference`s or `Variable`s.\n   */\n  readonly namedEntities = new Map<string, Reference|Variable>();\n\n  /**\n   * Child `Scope`s for immediately nested `Template`s.\n   */\n  readonly childScopes = new Map<Template, Scope>();\n\n  private constructor(readonly parentScope?: Scope) {}\n\n  /**\n   * Process a template (either as a `Template` sub-template with variables, or a plain array of\n   * template `Node`s) and construct its `Scope`.\n   */\n  static apply(template: Template|Node[]): Scope {\n    const scope = new Scope();\n    scope.ingest(template);\n    return scope;\n  }\n\n  /**\n   * Internal method to process the template and populate the `Scope`.\n   */\n  private ingest(template: Template|Node[]): void {\n    if (template instanceof Template) {\n      // Variables on an <ng-template> are defined in the inner scope.\n      template.variables.forEach(node => this.visitVariable(node));\n\n      // Process the nodes of the template.\n      template.children.forEach(node => node.visit(this));\n    } else {\n      // No overarching `Template` instance, so process the nodes directly.\n      template.forEach(node => node.visit(this));\n    }\n  }\n\n  visitElement(element: Element) {\n    // `Element`s in the template may have `Reference`s which are captured in the scope.\n    element.references.forEach(node => this.visitReference(node));\n\n    // Recurse into the `Element`'s children.\n    element.children.forEach(node => node.visit(this));\n  }\n\n  visitTemplate(template: Template) {\n    // References on a <ng-template> are defined in the outer scope, so capture them before\n    // processing the template's child scope.\n    template.references.forEach(node => this.visitReference(node));\n\n    // Next, create an inner scope and process the template within it.\n    const scope = new Scope(this);\n    scope.ingest(template);\n    this.childScopes.set(template, scope);\n  }\n\n  visitVariable(variable: Variable) {\n    // Declare the variable if it's not already.\n    this.maybeDeclare(variable);\n  }\n\n  visitReference(reference: Reference) {\n    // Declare the variable if it's not already.\n    this.maybeDeclare(reference);\n  }\n\n  // Unused visitors.\n  visitContent(content: Content) {}\n  visitBoundAttribute(attr: BoundAttribute) {}\n  visitBoundEvent(event: BoundEvent) {}\n  visitBoundText(text: BoundText) {}\n  visitText(text: Text) {}\n  visitTextAttribute(attr: TextAttribute) {}\n\n  private maybeDeclare(thing: Reference|Variable) {\n    // Declare something with a name, as long as that name isn't taken.\n    if (!this.namedEntities.has(thing.name)) {\n      this.namedEntities.set(thing.name, thing);\n    }\n  }\n\n  /**\n   * Look up a variable within this `Scope`.\n   *\n   * This can recurse into a parent `Scope` if it's available.\n   */\n  lookup(name: string): Reference|Variable|null {\n    if (this.namedEntities.has(name)) {\n      // Found in the local scope.\n      return this.namedEntities.get(name) !;\n    } else if (this.parentScope !== undefined) {\n      // Not in the local scope, but there's a parent scope so check there.\n      return this.parentScope.lookup(name);\n    } else {\n      // At the top level and it wasn't found.\n      return null;\n    }\n  }\n\n  /**\n   * Get the child scope for a `Template`.\n   *\n   * This should always be defined.\n   */\n  getChildScope(template: Template): Scope {\n    const res = this.childScopes.get(template);\n    if (res === undefined) {\n      throw new Error(`Assertion error: child scope for ${template} not found`);\n    }\n    return res;\n  }\n}\n\n/**\n * Processes a template and matches directives on nodes (elements and templates).\n *\n * Usually used via the static `apply()` method.\n */\nclass DirectiveBinder<DirectiveT extends DirectiveMeta> implements Visitor {\n  constructor(\n      private matcher: SelectorMatcher<DirectiveT>,\n      private directives: Map<Element|Template, DirectiveT[]>,\n      private bindings: Map<BoundAttribute|BoundEvent|TextAttribute, DirectiveT|Element|Template>,\n      private references:\n          Map<Reference, {directive: DirectiveT, node: Element|Template}|Element|Template>) {}\n\n  /**\n   * Process a template (list of `Node`s) and perform directive matching against each node.\n   *\n   * @param template the list of template `Node`s to match (recursively).\n   * @param selectorMatcher a `SelectorMatcher` containing the directives that are in scope for\n   * this template.\n   * @returns three maps which contain information about directives in the template: the\n   * `directives` map which lists directives matched on each node, the `bindings` map which\n   * indicates which directives claimed which bindings (inputs, outputs, etc), and the `references`\n   * map which resolves #references (`Reference`s) within the template to the named directive or\n   * template node.\n   */\n  static apply<DirectiveT extends DirectiveMeta>(\n      template: Node[], selectorMatcher: SelectorMatcher<DirectiveT>): {\n    directives: Map<Element|Template, DirectiveT[]>,\n    bindings: Map<BoundAttribute|BoundEvent|TextAttribute, DirectiveT|Element|Template>,\n    references: Map<Reference, {directive: DirectiveT, node: Element|Template}|Element|Template>,\n  } {\n    const directives = new Map<Element|Template, DirectiveT[]>();\n    const bindings =\n        new Map<BoundAttribute|BoundEvent|TextAttribute, DirectiveT|Element|Template>();\n    const references =\n        new Map<Reference, {directive: DirectiveT, node: Element | Template}|Element|Template>();\n    const matcher = new DirectiveBinder(selectorMatcher, directives, bindings, references);\n    matcher.ingest(template);\n    return {directives, bindings, references};\n  }\n\n  private ingest(template: Node[]): void { template.forEach(node => node.visit(this)); }\n\n  visitElement(element: Element): void { this.visitElementOrTemplate(element.name, element); }\n\n  visitTemplate(template: Template): void { this.visitElementOrTemplate('ng-template', template); }\n\n  visitElementOrTemplate(tag: string, node: Element|Template): void {\n    // First, determine the HTML shape of the node for the purpose of directive matching.\n    // Do this by building up a `CssSelector` for the node.\n    const cssSelector = new CssSelector();\n    cssSelector.setElement(tag);\n\n    // Add attributes to the CSS selector.\n    const attrs = getAttrsForDirectiveMatching(node);\n    Object.getOwnPropertyNames(attrs).forEach((name) => {\n      const value = attrs[name];\n\n      cssSelector.addAttribute(name, value);\n\n      // Treat the 'class' attribute specially.\n      if (name.toLowerCase() === 'class') {\n        const classes = value.trim().split(/\\s+/g);\n        classes.forEach(className => cssSelector.addClassName(className));\n      }\n    });\n\n    // Next, use the `SelectorMatcher` to get the list of directives on the node.\n    const directives: DirectiveT[] = [];\n    this.matcher.match(cssSelector, (_, directive) => directives.push(directive));\n    if (directives.length > 0) {\n      this.directives.set(node, directives);\n    }\n\n    // Resolve any references that are created on this node.\n    node.references.forEach(ref => {\n      let dirTarget: DirectiveT|null = null;\n\n      // If the reference expression is empty, then it matches the \"primary\" directive on the node\n      // (if there is one). Otherwise it matches the host node itself (either an element or\n      // <ng-template> node).\n      if (ref.value.trim() === '') {\n        // This could be a reference to a component if there is one.\n        dirTarget = directives.find(dir => dir.isComponent) || null;\n      } else {\n        // This is a reference to a directive exported via exportAs. One should exist.\n        dirTarget = directives.find(dir => dir.exportAs === ref.value) || null;\n\n        // Check if a matching directive was found, and error if it wasn't.\n        if (dirTarget === null) {\n          // TODO(alxhub): Return an error value here that can be used for template validation.\n          throw new Error(`Assertion error: failed to find directive with exportAs: ${ref.value}`);\n        }\n      }\n\n      if (dirTarget !== null) {\n        // This reference points to a directive.\n        this.references.set(ref, {directive: dirTarget, node});\n      } else {\n        // This reference points to the node itself.\n        this.references.set(ref, node);\n      }\n    });\n\n    // Associate bindings on the node with directives or with the node itself.\n\n    // Inputs:\n    [...node.attributes, ...node.inputs].forEach(binding => {\n      let dir = directives.find(dir => dir.inputs.hasOwnProperty(binding.name));\n      if (dir !== undefined) {\n        this.bindings.set(binding, dir);\n      } else {\n        this.bindings.set(binding, node);\n      }\n    });\n\n    // Outputs:\n    node.outputs.forEach(binding => {\n      let dir = directives.find(dir => dir.outputs.hasOwnProperty(binding.name));\n      if (dir !== undefined) {\n        this.bindings.set(binding, dir);\n      } else {\n        this.bindings.set(binding, node);\n      }\n    });\n\n    // Recurse into the node's children.\n    node.children.forEach(child => child.visit(this));\n  }\n\n  // Unused visitors.\n  visitContent(content: Content): void {}\n  visitVariable(variable: Variable): void {}\n  visitReference(reference: Reference): void {}\n  visitTextAttribute(attribute: TextAttribute): void {}\n  visitBoundAttribute(attribute: BoundAttribute): void {}\n  visitBoundEvent(attribute: BoundEvent): void {}\n  visitBoundAttributeOrEvent(node: BoundAttribute|BoundEvent) {}\n  visitText(text: Text): void {}\n  visitBoundText(text: BoundText): void {}\n}\n\n/**\n * Processes a template and extract metadata about expressions and symbols within.\n *\n * This is a companion to the `DirectiveBinder` that doesn't require knowledge of directives matched\n * within the template in order to operate.\n *\n * Expressions are visited by the superclass `RecursiveAstVisitor`, with custom logic provided\n * by overridden methods from that visitor.\n */\nclass TemplateBinder extends RecursiveAstVisitor implements Visitor {\n  private visitNode: (node: Node) => void;\n\n  private constructor(\n      private bindings: Map<AST, Reference|Variable>,\n      private symbols: Map<Reference|Variable, Template>,\n      private nestingLevel: Map<Template, number>, private scope: Scope,\n      private template: Template|null, private level: number) {\n    super();\n\n    // Save a bit of processing time by constructing this closure in advance.\n    this.visitNode = (node: Node) => node.visit(this);\n  }\n\n  /**\n   * Process a template and extract metadata about expressions and symbols within.\n   *\n   * @param template the nodes of the template to process\n   * @param scope the `Scope` of the template being processed.\n   * @returns three maps which contain metadata about the template: `expressions` which interprets\n   * special `AST` nodes in expressions as pointing to references or variables declared within the\n   * template, `symbols` which maps those variables and references to the nested `Template` which\n   * declares them, if any, and `nestingLevel` which associates each `Template` with a integer\n   * nesting level (how many levels deep within the template structure the `Template` is), starting\n   * at 1.\n   */\n  static apply(template: Node[], scope: Scope): {\n    expressions: Map<AST, Reference|Variable>,\n    symbols: Map<Variable|Reference, Template>,\n    nestingLevel: Map<Template, number>,\n  } {\n    const expressions = new Map<AST, Reference|Variable>();\n    const symbols = new Map<Variable|Reference, Template>();\n    const nestingLevel = new Map<Template, number>();\n    // The top-level template has nesting level 0.\n    const binder = new TemplateBinder(\n        expressions, symbols, nestingLevel, scope, template instanceof Template ? template : null,\n        0);\n    binder.ingest(template);\n    return {expressions, symbols, nestingLevel};\n  }\n\n  private ingest(template: Template|Node[]): void {\n    if (template instanceof Template) {\n      // For <ng-template>s, process inputs, outputs, variables, and child nodes. References were\n      // processed in the scope of the containing template.\n      template.inputs.forEach(this.visitNode);\n      template.outputs.forEach(this.visitNode);\n      template.variables.forEach(this.visitNode);\n      template.children.forEach(this.visitNode);\n\n      // Set the nesting level.\n      this.nestingLevel.set(template, this.level);\n    } else {\n      // Visit each node from the top-level template.\n      template.forEach(this.visitNode);\n    }\n  }\n\n  visitElement(element: Element) {\n    // Vist the inputs, outputs, and children of the element.\n    element.inputs.forEach(this.visitNode);\n    element.outputs.forEach(this.visitNode);\n    element.children.forEach(this.visitNode);\n  }\n\n  visitTemplate(template: Template) {\n    // First, visit the inputs, outputs of the template node.\n    template.inputs.forEach(this.visitNode);\n    template.outputs.forEach(this.visitNode);\n\n    // References are also evaluated in the outer context.\n    template.references.forEach(this.visitNode);\n\n    // Next, recurse into the template using its scope, and bumping the nesting level up by one.\n    const childScope = this.scope.getChildScope(template);\n    const binder = new TemplateBinder(\n        this.bindings, this.symbols, this.nestingLevel, childScope, template, this.level + 1);\n    binder.ingest(template);\n  }\n\n  visitVariable(variable: Variable) {\n    // Register the `Variable` as a symbol in the current `Template`.\n    if (this.template !== null) {\n      this.symbols.set(variable, this.template);\n    }\n  }\n\n  visitReference(reference: Reference) {\n    // Register the `Reference` as a symbol in the current `Template`.\n    if (this.template !== null) {\n      this.symbols.set(reference, this.template);\n    }\n  }\n\n  // Unused template visitors\n\n  visitText(text: Text) {}\n  visitContent(content: Content) {}\n  visitTextAttribute(attribute: TextAttribute) {}\n\n  // The remaining visitors are concerned with processing AST expressions within template bindings\n\n  visitBoundAttribute(attribute: BoundAttribute) { attribute.value.visit(this); }\n\n  visitBoundEvent(event: BoundEvent) { event.handler.visit(this); }\n\n  visitBoundText(text: BoundText) { text.value.visit(this); }\n\n\n\n  // These five types of AST expressions can refer to expression roots, which could be variables\n  // or references in the current scope.\n\n  visitPropertyRead(ast: PropertyRead, context: any): any {\n    this.maybeMap(context, ast, ast.name);\n    return super.visitPropertyRead(ast, context);\n  }\n\n  visitSafePropertyRead(ast: SafePropertyRead, context: any): any {\n    this.maybeMap(context, ast, ast.name);\n    return super.visitSafePropertyRead(ast, context);\n  }\n\n  visitPropertyWrite(ast: PropertyWrite, context: any): any {\n    this.maybeMap(context, ast, ast.name);\n    return super.visitPropertyWrite(ast, context);\n  }\n\n  visitMethodCall(ast: MethodCall, context: any): any {\n    this.maybeMap(context, ast, ast.name);\n    return super.visitMethodCall(ast, context);\n  }\n\n  visitSafeMethodCall(ast: SafeMethodCall, context: any): any {\n    this.maybeMap(context, ast, ast.name);\n    return super.visitSafeMethodCall(ast, context);\n  }\n\n  private maybeMap(\n      scope: Scope, ast: PropertyRead|SafePropertyRead|PropertyWrite|MethodCall|SafeMethodCall,\n      name: string): void {\n    // If the receiver of the expression isn't the `ImplicitReceiver`, this isn't the root of an\n    // `AST` expression that maps to a `Variable` or `Reference`.\n    if (!(ast.receiver instanceof ImplicitReceiver)) {\n      return;\n    }\n\n    // Check whether the name exists in the current scope. If so, map it. Otherwise, the name is\n    // probably a property on the top-level component context.\n    let target = this.scope.lookup(name);\n    if (target !== null) {\n      this.bindings.set(ast, target);\n    }\n  }\n}\n\n/**\n * Metadata container for a `Target` that allows queries for specific bits of metadata.\n *\n * See `BoundTarget` for documentation on the individual methods.\n */\nexport class R3BoundTarget<DirectiveT extends DirectiveMeta> implements BoundTarget<DirectiveT> {\n  constructor(\n      readonly target: Target, private directives: Map<Element|Template, DirectiveT[]>,\n      private bindings: Map<BoundAttribute|BoundEvent|TextAttribute, DirectiveT|Element|Template>,\n      private references:\n          Map<BoundAttribute|BoundEvent|Reference|TextAttribute,\n              {directive: DirectiveT, node: Element|Template}|Element|Template>,\n      private exprTargets: Map<AST, Reference|Variable>,\n      private symbols: Map<Reference|Variable, Template>,\n      private nestingLevel: Map<Template, number>) {}\n\n  getDirectivesOfNode(node: Element|Template): DirectiveT[]|null {\n    return this.directives.get(node) || null;\n  }\n\n  getReferenceTarget(ref: Reference): {directive: DirectiveT, node: Element|Template}|Element\n      |Template|null {\n    return this.references.get(ref) || null;\n  }\n\n  getConsumerOfBinding(binding: BoundAttribute|BoundEvent|TextAttribute): DirectiveT|Element\n      |Template|null {\n    return this.bindings.get(binding) || null;\n  }\n\n  getExpressionTarget(expr: AST): Reference|Variable|null {\n    return this.exprTargets.get(expr) || null;\n  }\n\n  getTemplateOfSymbol(symbol: Reference|Variable): Template|null {\n    return this.symbols.get(symbol) || null;\n  }\n\n  getNestingLevel(template: Template): number { return this.nestingLevel.get(template) || 0; }\n\n  getUsedDirectives(): DirectiveT[] {\n    const set = new Set<DirectiveT>();\n    this.directives.forEach(dirs => dirs.forEach(dir => set.add(dir)));\n    return Array.from(set.values());\n  }\n}\n"]}