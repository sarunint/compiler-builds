{"version":3,"file":"binding_parser.js","sourceRoot":"","sources":["../../../../../packages/compiler/src/template_parser/binding_parser.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {CompileDirectiveSummary, CompilePipeSummary} from '../compile_metadata';\nimport {SecurityContext} from '../core';\nimport {ASTWithSource, BindingPipe, BindingType, BoundElementProperty, EmptyExpr, ParsedEvent, ParsedEventType, ParsedProperty, ParsedPropertyType, ParsedVariable, ParserError, RecursiveAstVisitor, TemplateBinding} from '../expression_parser/ast';\nimport {Parser} from '../expression_parser/parser';\nimport {InterpolationConfig} from '../ml_parser/interpolation_config';\nimport {mergeNsAndName} from '../ml_parser/tags';\nimport {ParseError, ParseErrorLevel, ParseSourceSpan} from '../parse_util';\nimport {ElementSchemaRegistry} from '../schema/element_schema_registry';\nimport {CssSelector} from '../selector';\nimport {splitAtColon, splitAtPeriod} from '../util';\n\nconst PROPERTY_PARTS_SEPARATOR = '.';\nconst ATTRIBUTE_PREFIX = 'attr';\nconst CLASS_PREFIX = 'class';\nconst STYLE_PREFIX = 'style';\n\nconst ANIMATE_PROP_PREFIX = 'animate-';\n\n/**\n * Parses bindings in templates and in the directive host area.\n */\nexport class BindingParser {\n  pipesByName: Map<string, CompilePipeSummary>|null = null;\n\n  private _usedPipes: Map<string, CompilePipeSummary> = new Map();\n\n  constructor(\n      private _exprParser: Parser, private _interpolationConfig: InterpolationConfig,\n      private _schemaRegistry: ElementSchemaRegistry, pipes: CompilePipeSummary[]|null,\n      public errors: ParseError[]) {\n    // When the `pipes` parameter is `null`, do not check for used pipes\n    // This is used in IVY when we might not know the available pipes at compile time\n    if (pipes) {\n      const pipesByName: Map<string, CompilePipeSummary> = new Map();\n      pipes.forEach(pipe => pipesByName.set(pipe.name, pipe));\n      this.pipesByName = pipesByName;\n    }\n  }\n\n  getUsedPipes(): CompilePipeSummary[] { return Array.from(this._usedPipes.values()); }\n\n  createBoundHostProperties(dirMeta: CompileDirectiveSummary, sourceSpan: ParseSourceSpan):\n      ParsedProperty[]|null {\n    if (dirMeta.hostProperties) {\n      const boundProps: ParsedProperty[] = [];\n      Object.keys(dirMeta.hostProperties).forEach(propName => {\n        const expression = dirMeta.hostProperties[propName];\n        if (typeof expression === 'string') {\n          this.parsePropertyBinding(propName, expression, true, sourceSpan, [], boundProps);\n        } else {\n          this._reportError(\n              `Value of the host property binding \"${propName}\" needs to be a string representing an expression but got \"${expression}\" (${typeof expression})`,\n              sourceSpan);\n        }\n      });\n      return boundProps;\n    }\n    return null;\n  }\n\n  createDirectiveHostPropertyAsts(\n      dirMeta: CompileDirectiveSummary, elementSelector: string,\n      sourceSpan: ParseSourceSpan): BoundElementProperty[]|null {\n    const boundProps = this.createBoundHostProperties(dirMeta, sourceSpan);\n    return boundProps &&\n        boundProps.map((prop) => this.createBoundElementProperty(elementSelector, prop));\n  }\n\n  createDirectiveHostEventAsts(dirMeta: CompileDirectiveSummary, sourceSpan: ParseSourceSpan):\n      ParsedEvent[]|null {\n    if (dirMeta.hostListeners) {\n      const targetEvents: ParsedEvent[] = [];\n      Object.keys(dirMeta.hostListeners).forEach(propName => {\n        const expression = dirMeta.hostListeners[propName];\n        if (typeof expression === 'string') {\n          this.parseEvent(propName, expression, sourceSpan, [], targetEvents);\n        } else {\n          this._reportError(\n              `Value of the host listener \"${propName}\" needs to be a string representing an expression but got \"${expression}\" (${typeof expression})`,\n              sourceSpan);\n        }\n      });\n      return targetEvents;\n    }\n    return null;\n  }\n\n  parseInterpolation(value: string, sourceSpan: ParseSourceSpan): ASTWithSource {\n    const sourceInfo = sourceSpan.start.toString();\n\n    try {\n      const ast =\n          this._exprParser.parseInterpolation(value, sourceInfo, this._interpolationConfig) !;\n      if (ast) this._reportExpressionParserErrors(ast.errors, sourceSpan);\n      this._checkPipes(ast, sourceSpan);\n      return ast;\n    } catch (e) {\n      this._reportError(`${e}`, sourceSpan);\n      return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo);\n    }\n  }\n\n  // Parse an inline template binding. ie `<tag *tplKey=\"<tplValue>\">`\n  parseInlineTemplateBinding(\n      tplKey: string, tplValue: string, sourceSpan: ParseSourceSpan,\n      targetMatchableAttrs: string[][], targetProps: ParsedProperty[],\n      targetVars: ParsedVariable[]) {\n    const bindings = this._parseTemplateBindings(tplKey, tplValue, sourceSpan);\n\n    for (let i = 0; i < bindings.length; i++) {\n      const binding = bindings[i];\n      if (binding.keyIsVar) {\n        targetVars.push(new ParsedVariable(binding.key, binding.name, sourceSpan));\n      } else if (binding.expression) {\n        this._parsePropertyAst(\n            binding.key, binding.expression, sourceSpan, targetMatchableAttrs, targetProps);\n      } else {\n        targetMatchableAttrs.push([binding.key, '']);\n        this.parseLiteralAttr(binding.key, null, sourceSpan, targetMatchableAttrs, targetProps);\n      }\n    }\n  }\n\n  private _parseTemplateBindings(tplKey: string, tplValue: string, sourceSpan: ParseSourceSpan):\n      TemplateBinding[] {\n    const sourceInfo = sourceSpan.start.toString();\n\n    try {\n      const bindingsResult = this._exprParser.parseTemplateBindings(tplKey, tplValue, sourceInfo);\n      this._reportExpressionParserErrors(bindingsResult.errors, sourceSpan);\n      bindingsResult.templateBindings.forEach((binding) => {\n        if (binding.expression) {\n          this._checkPipes(binding.expression, sourceSpan);\n        }\n      });\n      bindingsResult.warnings.forEach(\n          (warning) => { this._reportError(warning, sourceSpan, ParseErrorLevel.WARNING); });\n      return bindingsResult.templateBindings;\n    } catch (e) {\n      this._reportError(`${e}`, sourceSpan);\n      return [];\n    }\n  }\n\n  parseLiteralAttr(\n      name: string, value: string|null, sourceSpan: ParseSourceSpan,\n      targetMatchableAttrs: string[][], targetProps: ParsedProperty[]) {\n    if (isAnimationLabel(name)) {\n      name = name.substring(1);\n      if (value) {\n        this._reportError(\n            `Assigning animation triggers via @prop=\"exp\" attributes with an expression is invalid.` +\n                ` Use property bindings (e.g. [@prop]=\"exp\") or use an attribute without a value (e.g. @prop) instead.`,\n            sourceSpan, ParseErrorLevel.ERROR);\n      }\n      this._parseAnimation(name, value, sourceSpan, targetMatchableAttrs, targetProps);\n    } else {\n      targetProps.push(new ParsedProperty(\n          name, this._exprParser.wrapLiteralPrimitive(value, ''), ParsedPropertyType.LITERAL_ATTR,\n          sourceSpan));\n    }\n  }\n\n  parsePropertyBinding(\n      name: string, expression: string, isHost: boolean, sourceSpan: ParseSourceSpan,\n      targetMatchableAttrs: string[][], targetProps: ParsedProperty[]) {\n    let isAnimationProp = false;\n    if (name.startsWith(ANIMATE_PROP_PREFIX)) {\n      isAnimationProp = true;\n      name = name.substring(ANIMATE_PROP_PREFIX.length);\n    } else if (isAnimationLabel(name)) {\n      isAnimationProp = true;\n      name = name.substring(1);\n    }\n\n    if (isAnimationProp) {\n      this._parseAnimation(name, expression, sourceSpan, targetMatchableAttrs, targetProps);\n    } else {\n      this._parsePropertyAst(\n          name, this._parseBinding(expression, isHost, sourceSpan), sourceSpan,\n          targetMatchableAttrs, targetProps);\n    }\n  }\n\n  parsePropertyInterpolation(\n      name: string, value: string, sourceSpan: ParseSourceSpan, targetMatchableAttrs: string[][],\n      targetProps: ParsedProperty[]): boolean {\n    const expr = this.parseInterpolation(value, sourceSpan);\n    if (expr) {\n      this._parsePropertyAst(name, expr, sourceSpan, targetMatchableAttrs, targetProps);\n      return true;\n    }\n    return false;\n  }\n\n  private _parsePropertyAst(\n      name: string, ast: ASTWithSource, sourceSpan: ParseSourceSpan,\n      targetMatchableAttrs: string[][], targetProps: ParsedProperty[]) {\n    targetMatchableAttrs.push([name, ast.source !]);\n    targetProps.push(new ParsedProperty(name, ast, ParsedPropertyType.DEFAULT, sourceSpan));\n  }\n\n  private _parseAnimation(\n      name: string, expression: string|null, sourceSpan: ParseSourceSpan,\n      targetMatchableAttrs: string[][], targetProps: ParsedProperty[]) {\n    // This will occur when a @trigger is not paired with an expression.\n    // For animations it is valid to not have an expression since */void\n    // states will be applied by angular when the element is attached/detached\n    const ast = this._parseBinding(expression || 'undefined', false, sourceSpan);\n    targetMatchableAttrs.push([name, ast.source !]);\n    targetProps.push(new ParsedProperty(name, ast, ParsedPropertyType.ANIMATION, sourceSpan));\n  }\n\n  private _parseBinding(value: string, isHostBinding: boolean, sourceSpan: ParseSourceSpan):\n      ASTWithSource {\n    const sourceInfo = (sourceSpan && sourceSpan.start || '(unknown)').toString();\n\n    try {\n      const ast = isHostBinding ?\n          this._exprParser.parseSimpleBinding(value, sourceInfo, this._interpolationConfig) :\n          this._exprParser.parseBinding(value, sourceInfo, this._interpolationConfig);\n      if (ast) this._reportExpressionParserErrors(ast.errors, sourceSpan);\n      this._checkPipes(ast, sourceSpan);\n      return ast;\n    } catch (e) {\n      this._reportError(`${e}`, sourceSpan);\n      return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo);\n    }\n  }\n\n  createBoundElementProperty(elementSelector: string, boundProp: ParsedProperty):\n      BoundElementProperty {\n    if (boundProp.isAnimation) {\n      return new BoundElementProperty(\n          boundProp.name, BindingType.Animation, SecurityContext.NONE, boundProp.expression, null,\n          boundProp.sourceSpan);\n    }\n\n    let unit: string|null = null;\n    let bindingType: BindingType = undefined !;\n    let boundPropertyName: string|null = null;\n    const parts = boundProp.name.split(PROPERTY_PARTS_SEPARATOR);\n    let securityContexts: SecurityContext[] = undefined !;\n\n    // Check check for special cases (prefix style, attr, class)\n    if (parts.length > 1) {\n      if (parts[0] == ATTRIBUTE_PREFIX) {\n        boundPropertyName = parts[1];\n        this._validatePropertyOrAttributeName(boundPropertyName, boundProp.sourceSpan, true);\n        securityContexts = calcPossibleSecurityContexts(\n            this._schemaRegistry, elementSelector, boundPropertyName, true);\n\n        const nsSeparatorIdx = boundPropertyName.indexOf(':');\n        if (nsSeparatorIdx > -1) {\n          const ns = boundPropertyName.substring(0, nsSeparatorIdx);\n          const name = boundPropertyName.substring(nsSeparatorIdx + 1);\n          boundPropertyName = mergeNsAndName(ns, name);\n        }\n\n        bindingType = BindingType.Attribute;\n      } else if (parts[0] == CLASS_PREFIX) {\n        boundPropertyName = parts[1];\n        bindingType = BindingType.Class;\n        securityContexts = [SecurityContext.NONE];\n      } else if (parts[0] == STYLE_PREFIX) {\n        unit = parts.length > 2 ? parts[2] : null;\n        boundPropertyName = parts[1];\n        bindingType = BindingType.Style;\n        securityContexts = [SecurityContext.STYLE];\n      }\n    }\n\n    // If not a special case, use the full property name\n    if (boundPropertyName === null) {\n      boundPropertyName = this._schemaRegistry.getMappedPropName(boundProp.name);\n      securityContexts = calcPossibleSecurityContexts(\n          this._schemaRegistry, elementSelector, boundPropertyName, false);\n      bindingType = BindingType.Property;\n      this._validatePropertyOrAttributeName(boundPropertyName, boundProp.sourceSpan, false);\n    }\n\n    return new BoundElementProperty(\n        boundPropertyName, bindingType, securityContexts[0], boundProp.expression, unit,\n        boundProp.sourceSpan);\n  }\n\n  parseEvent(\n      name: string, expression: string, sourceSpan: ParseSourceSpan,\n      targetMatchableAttrs: string[][], targetEvents: ParsedEvent[]) {\n    if (isAnimationLabel(name)) {\n      name = name.substr(1);\n      this._parseAnimationEvent(name, expression, sourceSpan, targetEvents);\n    } else {\n      this._parseRegularEvent(name, expression, sourceSpan, targetMatchableAttrs, targetEvents);\n    }\n  }\n\n  private _parseAnimationEvent(\n      name: string, expression: string, sourceSpan: ParseSourceSpan, targetEvents: ParsedEvent[]) {\n    const matches = splitAtPeriod(name, [name, '']);\n    const eventName = matches[0];\n    const phase = matches[1].toLowerCase();\n    if (phase) {\n      switch (phase) {\n        case 'start':\n        case 'done':\n          const ast = this._parseAction(expression, sourceSpan);\n          targetEvents.push(\n              new ParsedEvent(eventName, phase, ParsedEventType.Animation, ast, sourceSpan));\n          break;\n\n        default:\n          this._reportError(\n              `The provided animation output phase value \"${phase}\" for \"@${eventName}\" is not supported (use start or done)`,\n              sourceSpan);\n          break;\n      }\n    } else {\n      this._reportError(\n          `The animation trigger output event (@${eventName}) is missing its phase value name (start or done are currently supported)`,\n          sourceSpan);\n    }\n  }\n\n  private _parseRegularEvent(\n      name: string, expression: string, sourceSpan: ParseSourceSpan,\n      targetMatchableAttrs: string[][], targetEvents: ParsedEvent[]) {\n    // long format: 'target: eventName'\n    const [target, eventName] = splitAtColon(name, [null !, name]);\n    const ast = this._parseAction(expression, sourceSpan);\n    targetMatchableAttrs.push([name !, ast.source !]);\n    targetEvents.push(new ParsedEvent(eventName, target, ParsedEventType.Regular, ast, sourceSpan));\n    // Don't detect directives for event names for now,\n    // so don't add the event name to the matchableAttrs\n  }\n\n  private _parseAction(value: string, sourceSpan: ParseSourceSpan): ASTWithSource {\n    const sourceInfo = (sourceSpan && sourceSpan.start || '(unknown').toString();\n\n    try {\n      const ast = this._exprParser.parseAction(value, sourceInfo, this._interpolationConfig);\n      if (ast) {\n        this._reportExpressionParserErrors(ast.errors, sourceSpan);\n      }\n      if (!ast || ast.ast instanceof EmptyExpr) {\n        this._reportError(`Empty expressions are not allowed`, sourceSpan);\n        return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo);\n      }\n      this._checkPipes(ast, sourceSpan);\n      return ast;\n    } catch (e) {\n      this._reportError(`${e}`, sourceSpan);\n      return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo);\n    }\n  }\n\n  private _reportError(\n      message: string, sourceSpan: ParseSourceSpan,\n      level: ParseErrorLevel = ParseErrorLevel.ERROR) {\n    this.errors.push(new ParseError(sourceSpan, message, level));\n  }\n\n  private _reportExpressionParserErrors(errors: ParserError[], sourceSpan: ParseSourceSpan) {\n    for (const error of errors) {\n      this._reportError(error.message, sourceSpan);\n    }\n  }\n\n  // Make sure all the used pipes are known in `this.pipesByName`\n  private _checkPipes(ast: ASTWithSource, sourceSpan: ParseSourceSpan): void {\n    if (ast && this.pipesByName) {\n      const collector = new PipeCollector();\n      ast.visit(collector);\n      collector.pipes.forEach((ast, pipeName) => {\n        const pipeMeta = this.pipesByName !.get(pipeName);\n        if (!pipeMeta) {\n          this._reportError(\n              `The pipe '${pipeName}' could not be found`,\n              new ParseSourceSpan(\n                  sourceSpan.start.moveBy(ast.span.start), sourceSpan.start.moveBy(ast.span.end)));\n        } else {\n          this._usedPipes.set(pipeName, pipeMeta);\n        }\n      });\n    }\n  }\n\n  /**\n   * @param propName the name of the property / attribute\n   * @param sourceSpan\n   * @param isAttr true when binding to an attribute\n   */\n  private _validatePropertyOrAttributeName(\n      propName: string, sourceSpan: ParseSourceSpan, isAttr: boolean): void {\n    const report = isAttr ? this._schemaRegistry.validateAttribute(propName) :\n                            this._schemaRegistry.validateProperty(propName);\n    if (report.error) {\n      this._reportError(report.msg !, sourceSpan, ParseErrorLevel.ERROR);\n    }\n  }\n}\n\nexport class PipeCollector extends RecursiveAstVisitor {\n  pipes = new Map<string, BindingPipe>();\n  visitPipe(ast: BindingPipe, context: any): any {\n    this.pipes.set(ast.name, ast);\n    ast.exp.visit(this);\n    this.visitAll(ast.args, context);\n    return null;\n  }\n}\n\nfunction isAnimationLabel(name: string): boolean {\n  return name[0] == '@';\n}\n\nexport function calcPossibleSecurityContexts(\n    registry: ElementSchemaRegistry, selector: string, propName: string,\n    isAttribute: boolean): SecurityContext[] {\n  const ctxs: SecurityContext[] = [];\n  CssSelector.parse(selector).forEach((selector) => {\n    const elementNames = selector.element ? [selector.element] : registry.allKnownElementNames();\n    const notElementNames =\n        new Set(selector.notSelectors.filter(selector => selector.isElementSelector())\n                    .map((selector) => selector.element));\n    const possibleElementNames =\n        elementNames.filter(elementName => !notElementNames.has(elementName));\n\n    ctxs.push(...possibleElementNames.map(\n        elementName => registry.securityContext(elementName, propName, isAttribute)));\n  });\n  return ctxs.length === 0 ? [SecurityContext.NONE] : Array.from(new Set(ctxs)).sort();\n}\n"]}