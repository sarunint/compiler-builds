{"version":3,"file":"injectable_compiler_2.js","sourceRoot":"","sources":["../../../../packages/compiler/src/injectable_compiler_2.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {InjectFlags} from './core';\nimport {Identifiers} from './identifiers';\nimport * as o from './output/output_ast';\nimport {R3DependencyMetadata, R3FactoryDelegateType, R3FactoryMetadata, compileFactoryFunction} from './render3/r3_factory';\nimport {mapToMapExpression} from './render3/util';\n\nexport interface InjectableDef {\n  expression: o.Expression;\n  type: o.Type;\n  statements: o.Statement[];\n}\n\nexport interface R3InjectableMetadata {\n  name: string;\n  type: o.Expression;\n  ctorDeps: R3DependencyMetadata[]|null;\n  providedIn: o.Expression;\n  useClass?: o.Expression;\n  useFactory?: o.Expression;\n  useExisting?: o.Expression;\n  useValue?: o.Expression;\n  userDeps?: R3DependencyMetadata[];\n}\n\nexport function compileInjectable(meta: R3InjectableMetadata): InjectableDef {\n  let result: {factory: o.Expression, statements: o.Statement[]}|null = null;\n\n  function makeFn(ret: o.Expression): o.Expression {\n    return o.fn([], [new o.ReturnStatement(ret)], undefined, undefined, `${meta.name}_Factory`);\n  }\n\n  const factoryMeta = {\n    name: meta.name,\n    type: meta.type,\n    deps: meta.ctorDeps,\n    injectFn: Identifiers.inject,\n    extraStatementFn: null,\n  };\n\n  if (meta.useClass !== undefined) {\n    // meta.useClass has two modes of operation. Either deps are specified, in which case `new` is\n    // used to instantiate the class with dependencies injected, or deps are not specified and\n    // the factory of the class is used to instantiate it.\n    //\n    // A special case exists for useClass: Type where Type is the injectable type itself, in which\n    // case omitting deps just uses the constructor dependencies instead.\n\n    const useClassOnSelf = meta.useClass.isEquivalent(meta.type);\n    const deps = meta.userDeps || (useClassOnSelf && meta.ctorDeps) || undefined;\n\n    if (deps !== undefined) {\n      // factory: () => new meta.useClass(...deps)\n      result = compileFactoryFunction({\n        ...factoryMeta,\n        delegate: meta.useClass,\n        delegateDeps: deps,\n        delegateType: R3FactoryDelegateType.Class,\n      });\n    } else {\n      result = compileFactoryFunction({\n        ...factoryMeta,\n        delegate: meta.useClass,\n        delegateType: R3FactoryDelegateType.Factory,\n      });\n    }\n  } else if (meta.useFactory !== undefined) {\n    result = compileFactoryFunction({\n      ...factoryMeta,\n      delegate: meta.useFactory,\n      delegateDeps: meta.userDeps || [],\n      delegateType: R3FactoryDelegateType.Function,\n    });\n  } else if (meta.useValue !== undefined) {\n    // Note: it's safe to use `meta.useValue` instead of the `USE_VALUE in meta` check used for\n    // client code because meta.useValue is an Expression which will be defined even if the actual\n    // value is undefined.\n    result = compileFactoryFunction({\n      ...factoryMeta,\n      expression: meta.useValue,\n    });\n  } else if (meta.useExisting !== undefined) {\n    // useExisting is an `inject` call on the existing token.\n    result = compileFactoryFunction({\n      ...factoryMeta,\n      expression: o.importExpr(Identifiers.inject).callFn([meta.useExisting]),\n    });\n  } else {\n    result = compileFactoryFunction(factoryMeta);\n  }\n\n  const token = meta.type;\n  const providedIn = meta.providedIn;\n\n  const expression = o.importExpr(Identifiers.defineInjectable).callFn([mapToMapExpression(\n      {token, factory: result.factory, providedIn})]);\n  const type = new o.ExpressionType(\n      o.importExpr(Identifiers.InjectableDef, [new o.ExpressionType(meta.type)]));\n\n  return {\n    expression,\n    type,\n    statements: result.statements,\n  };\n}\n"]}